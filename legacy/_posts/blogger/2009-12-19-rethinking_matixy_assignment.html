---
layout: bloggerpost
title: Rethinking Matixy Assignment
publish: true
categories: [Parrot, Matrixy]
---

Variadic output arguments have been <a href="/2009/12/10/matrixy_progress.html.html">partially implemented in Matrixy</a> in the "varargout" branch, but I'm starting to hit a wall with the current implementation. At the very least, it's not a clean or well-designed implementation of it. The parser is using all sorts of weird global variables and there are too many special cases to deal with.<br /><br />A big portion of the issue is the problem with ambiguity between a matrix index and a function call. This statement can be either a call to function foo, or an index into matrix foo:<br /><pre><br />a = foo(b, c);<br /></pre><br />And, functions (but not matrices) can return multiple values:<br /><pre><br />[a, b(3), c(4, 5)] = foo(x, y);<br /></pre><br />So when we parse the first set of values, we don't know until we've parsed the equals-sign if it's this:<br /><pre><br />[a, b(3), c(4, 5)];<br /></pre><br />which is shorthand for this:<br /><pre><br />ans = [a, b(3), c(4, 5)];<br /></pre><br />But, I've harped on these problems all before, and I won't dig into it in depth here. What I think we need to do in Matrixy to bring some sanity back to the parser, is to create a matrix reference object that can be used to retrieve or modify values in a matrix object comprised of a combination of constant and variable references. So this line:<br /><pre><br />x = [a, b(3), c(4, 5)];<br /></pre><br />becomes this PIR code sequence:<br /><pre><br />$P0 = !index_ref(a)<br />$P1 = !index_ref(b, 3)<br />$P2 = !index_ref(c, 4, 5)<br />$P3 = !build_literal_matrix($P0, $P1, $P2)<br />$P4 = !index_ref(x)<br />$P3.extract_as_rvalue($P4)<br /></pre><br />And this:<br /><pre><br />[a, b(3), c(4, 5)] = foo()<br /></pre><br />Becomes this:<br /><pre><br />$P0 = !index_ref(a)<br />$P1 = !index_ref(b, 3)<br />$P2 = !index_ref(c, 4, 5)<br />$P3 = !matrix_accessor($P0, $P1, $P2)<br />$P4 = !index_ref(foo)<br />$P3.assign_as_lvalue($P4)<br /></pre><br />Of course these are just first drafts of the call sequences and the method names, but it does illustrate the general idea. This is going to add a pretty significant number of function calls and created PMCs to the normal control flow too, but I can worry about optimizing things once they all work.<br /><br />When we attempt to pull a value from a reference object, we'll determine whether it's a matrix or a function call and handle it accordingly. If we're pushing a value to it as in an assignment, we always just assume it's a matrix. M, to the best of my knowledge, doesn't support L-value function calls.<br /><br />Soon I'm going to merge the varargout branch where I have been working on variadic output arguments. Even though I know this isn't the approach I will be taking in the long term this branch does include a number of important regression tests and other refactors and enhancements that I don't want to lose. I might not end up getting to this issue until after Parrot's 2.0 release, however.