---
layout: bloggerpost
title: Octave Data
publish: true
categories: []
---

I played around a little bit today with my Octave implementation, and I'm happy to say that I had a major breakthrough and was able to get functions working, mostly. Now, for instance, the following code works as expected:<br /><pre>function [c] = circumference(r)<br />  c = 2 * pi() * r;<br />end<br /><br />x = circumference(5)</pre><br />Which will dutifully print out the expected result:<br /><pre>x =<br /><br />  31.4159</pre><br />Despite the square brackets in the function declaration, I haven't gotten matrices up and running yet, although they are basically the next thing on the list. I've created a basic "OctaveData" super class, and am going to create a series of sub-classes for the various data items (matrices, scalars, cell arrays). The superclass will contain a flag for the data type, so that functions can determine the types of input arguments (probably through the isa() function) and act accordingly.<br /><br />When an identifier is found, we can search a list for it. There will be several lists, one for top-level declarations, one for the current lexical scope, and one for variables declared as "global". I search the list for the given variable, and if it is found, I can return the value. In the case of a matrix, the following call:<br /><pre>y = x(1, 2)</pre><br />Will return the element from column 1, row 2 of matrix x. However, if no variables are found in any of the lists, a dispatch method is called to find and call a function by that name. If x in our example above is a function, the dispatch method will return the result of function x with the arguments 1 and 2. The benefit to having a dispatch method is that I can centralize the search function and the wrap-the-return-values-into-a-matrix functionality in the same place, and only have to deal with it once.<br /><br />I have some basic loop structures that I stole from Squaak, and I need to tweak them a little bit so they match the Octave syntax more closely. With loops, subroutines, and aggregate data types, I will basically be in a position to start reproducing standard library functions. I'm pretty impressed with the progress I've been making, especially considering how little time I have on a regular basis to work on it.