---
layout: bloggerpost
title: Continuation Passing Style
---

There has been a lot of discussion recently about Lorito, since it's become a huge priority for the community. Some people have taken to calling the basics of Lorito "M0", which I find particularly humorous since we used to call it "L1" and changed it to "Lorito" for clarity. Regardless, today I'm going to talk a little bit about Continuation-Passing-Style (CPS) control flow and try and clear up some of the confusions that people seem to be having about it.<br /><br />CPS, in a nutshell, treats all control flow (or, most of it) as a single type of object called a <b>continuation</b>. A continuation is like a combination between a goto and a function call, but more powerful. The continuation object corresponds to a snapshot in time of the state of the virtual machine, and also has a label. When the continuation is invoked, taking arguments like a subroutine would, the virtual machine state is rewound to the point when the continuation is created and control flow jumps to that label.<br /><br />In plain English, the continuation is a "continue from here" or "continue from there" operation. Stop what you are doing and go back to this place. A function call is easy: Continue in this routine. A function return is a little more tricky: Continue from the point of the call. Exceptions: continue at the nearest exception handler. Exception resume: continue back at the point where the exception was thrown. Green threads: Continue a previous task that is waiting to run. In stack-based languages there are differences in mechanism depending on whether we are going to or returning from a subroutine, jumping to a label, or performing a longjmp. In CPS, these are all the same "continue over there" operation. Where what "over there" is differentiates between different-looking control flow mechanisms.<br /><br />This all sounds well and good until you start to look at this more closely. In the case of a return, how does the return statement know where to return to inside the body of the caller? For that matter, how does the subroutine know who called it at all? The answer is that we have to pass that information along to the callee.<br /><br />In a stack-based language, this is all easy. When we make a function call we push a return address onto the call stack, then execute the function. At the end of the function we pop the return address off the call stack and return to that. In CPS it's actually not much harder: We create a return continuation and pass that as one of the arguments to the function.<br /><br />In a stack-based language:<br /><br /><br />function bar()<br />  foo()<br />  ... <br /><br />function foo()<br />  return<br /><br />In a CPS-based language:<br /><br />function bar()<br />  ret = new continuation(after_bar)<br />  foo(ret)<br />  after_bar:<br />  ...<br /><br />function foo(ret)<br />  ret()<br /><br />In the classical examples, the return continuation in a CPS language is always explicitly passed as the first argument to a function call. In a language like Parrot's PIR, the return continuation is implicitly passed into the execution context object of the called function, and is not treated like an argument. Actually this isn't entirely true. The "invokecc" opcode, which Parrot uses by default when you invoke a sub with the () parenthesis postcircumfix operator. However, it also provides a normal "invoke" opcode which allows you to explicitly specify the continuation to use. In either case, it's not passed as a normal argument.<br /><br />In Lorito there is talk that it should get back to the classical style of explicitly passing continuations to subroutines. I like this idea for a lot of reasons. First, Lorito is going to be almost entirely generated code. People aren't going to be writing it, for the most part, so we can require a certain number of extra steps and required syntax. Also, we gain finer-tuned control over some types of optimizations (such as tailcall optimizations) because we can be more creative with what we pass to a function as the return continuation.