---
layout: bloggerpost
title: ParrotTheory: The C System Stack
---

I talked a lot about control flow on the C system stack in <a href="http://wknight8111.blogspot.com/2009/09/exception-handlers-done-right.html">my post about the inferior runloops problem in Parrot</a>. Since not everybody is familiar with all the mechanics of the platform ABI, I figured I would write up a theory post about how all that works.<br /><br /><span style="font-size:180%;">C and Assembly Code</span><br /><br />The compilation process for a language like C is very straight-forward: Write C code, invoke compiler, convert code to machine code, execute it. Ultimately for a program written in C code or any language at all for that matter to execute, it must be converted to a stream of machine code instructions. The hardware simply doesn't understand anything else. Any C code can be translated, by hand if necessary into an equivalent sequence of assembly instructions, which in turn can be translated (again, you can do this by hand) into machine code. Assembly instructions and machine code tend to have a one-to-one relationship, but C code has a one-to-many relationship with assembly. It's these variants that an optimizer searches for, finding faster ways to perform the same operations. It is also possible to convert a listing of assembly code into equivalent C code. This is called "decompilation", and is an important technique in the field of reverse engineering.<br /><br />C code and assembly can be converted back and forth, and are generally equivalent. There are some operations in assembly that cannot be strictly converted to C code, but that's a subset we are able to ignore for now.<br /><br /><span style="font-size:180%;">Function Calls</span><br /><br />Look now at a piece of C code that we should all be familiar with, a function call:<br /><pre><br />x = Foo(a, b, c)<br /></pre><br />This line of code translates, more or less, into this sequence of x86 assembly:<br /><pre><br />mov eax, 'c'<br />push eax<br />mov eax, 'b'<br />push eax<br />mov eax 'a'<br />push eax<br />call _Foo<br />mov 'x', eax<br />sub esp, 12<br /></pre><br />I'm obviously simplifying in some places. This is probably not what your compiler would actually generate, but is not entirely dissimilar to what you would get if variables <code>a</code>, <code>b</code>, <code>c</code>, and <code>x</code> were all declared volatile, and if you didn't optimize. To make a function call, the arguments are all pushed onto the system stack (usually in left-to-right order) and the function is called. The '<code>call</code>' operation does two things: it pushes a return address onto the stack and then jumps to the function Foo. When the function returns, the return value is stored in the <code>eax</code> register (except floating-point values, which are different and beyond the scope of this post). The important point to take away from this is that the arguments and the function return value are all on the system stack in a very particular order when the function call was made. Notice also that we need to "clean" the stack after the function call: We move the stack pointer back to where it was before pushing the three arguments. The return address is popped automatically in the <code>ret</code> command that we will see next.<br /><br />As a general rule, the calling function should have absolutely no knowledge or interaction with the callee's stack frame or anything below it. Likewise, the callee should have no knowledge of the caller's stack frame or anything above it.<br /><br />Now, let's look at the guts of the function Foo. Here's some C code to implement it:<br /><pre><br />int Foo(int a, int b, int c)<br />{<br />   return a  +  b  + c;<br />}<br /></pre><br />Converting to assembly, this is:<br /><pre><br />_Foo:<br />mov eax, 0<br />mov ebx, [esp+4]<br />add eax, ebx<br />mov ebx, [esp+8]<br />add eax, ebx<br />mov ebx, [esp+12]<br />add eax, ebx<br />ret<br /></pre><br />Again, not what you are likely to actually see as the output from a good compiler. I've intentionally omitted some details for simplicity. The values a, b and c are stored on the stack, so internally to the function we read them off the stack using offsets of the esp stack register. We cannot pop the values here because popping would move the return address (it's on the top of the stack, remember).<br /><br /><span style="font-size:180%;">The Stack</span><br /><br />This is all well and good for the simple example, but what if we want to have local variables in the function? And more importantly, how do we make local variables in a way that we can recurse properly? To do this, we need to create a <span style="font-weight: bold;">stack frame</span>. But before we talk about frames, let's talk about the stack.<br /><br />The stack is just a contiguous region of memory that is pointed to by the stack register <code>esp</code>. The stack grows "down", so it starts at a high value in memory and each additional item pushed goes to the next lowest place on the stack. The "<code>push eax</code>" instruction does this, essentially:<br /><pre><br />mov [esp], eax<br />sub esp, 4<br /></pre><br />And the "<code>pop eax</code>" instruction reverses this process:<br /><pre><br />add esp, 4<br />mov eax, [esp]<br /></pre><br />The biggest difference is that the push and pop instructions execute much more quickly then the add/mov combination does otherwise.<br /><br /><span style="font-size:180%;">Stack Frames</span><br /><br />With this knowledge of the stack, we can now talk about local variables in a function. Let's rewrite Foo to have some local temporary variables:<br /><pre><br />int Foo(int a, int b, int c)<br />{<br />  int x, y;<br />  x = a + b;<br />  y = x + c;<br />  return y;<br />}<br /></pre><br />Converting to assembly now, we create space on the stack for x and y:<br /><pre><br />_Foo:<br />push ebp   ; Save the old value of ebp<br />mov ebp, esp ; ebp points to the stack<br />sub esp, 8 ; make space on the stack for x and y<br />...<br />mov esp, ebp<br />pop ebp<br />ret<br /></pre><br />The code I've shown you here is nearly identical for every function created in C. These are the <span style="font-style: italic;">standard entry and exit sequences</span> for x86 machines. The old value of <code>ebp</code> is pushed onto the stack to save it. This is so we can recurse easily without having to worry about the caller's stack. <code>ebp</code> is then set to point to <code>esp</code>, the "top" of the stack. Then we decrease <code>esp</code>, creating space on the stack to store local variables without having to manually "push" space for each one individually. From this point forward we can address all function arguments as offsets from <code>ebp</code>, and all function variables as offsets from <code>esp</code>. This moving stack frame allows us to recurse the function with no limitations besides stack space. Inside the function this is where the variables are stored. Remember that in x86 assembly, the <code>[]</code> brackets are pointer dereferences like "prefix:*" in C.<br /><ul><li>old ebp = <code>[ebp]</code></li><li>return value = <code>[ebp + 4]</code><br /></li><li>a = <code>[ebp + 8]</code></li><li>b = <code>[ebp + 12]</code></li><li>c = <code>[ebp + 16]</code></li><li>x = <code>[esp + 0]</code></li><li>y = <code>[esp + 4]</code></li></ul>When we return, we move <code>esp</code> back to where <code>ebp</code> is, pop the stored value of <code>ebp</code> off the stack (for the calling function), and then pop the return address off the stack and jump to it. In the calling function we "<code>add esp 12</code>" to clean up the arguments from the stack and continue execution from there.<br /><br />It's worth mentioning that if we create storage on the stack, such as a string or array, and write past the bounds of that array, we can accidentally overwrite things like the stored value of <code>ebp</code> or even the return address. A <span style="font-weight: bold;">stack overflow attack</span> does this exact thing to write a specific value to the return address, which causes execution to "return" to somebody's malicious code somewhere. The C standard library string.h is notorious for allowing these kinds of things to happen.<br /><br />When I talk about having functions "on the stack", what I mean is that we have stack frames for those functions on the stack above where we are currently executing.<br /><br /><span style="font-size:180%;">Backtraces</span><br /><br />If we look at a backtrace in a debugger like GDB, we see a listing of functions representing a call sequence. This sequence can be found by tracing the stack: starting at the current function and iterating over the stack. GDB can find the return address at <code>[ebp + 4]</code>, follow that to the caller function, and repeat the process until we reach <code>main()</code>. Combine finding addresses with finding metadata about the function name (in terms of debugging symbols) and we can produce a proper backtrace. Commands in GDB follow a lot of stack terminology: "frame" shows us the current frame, "up" moves us up to the previous stack frame and "down" moves us down to the next stack frame.<br /><br /><span style="font-size:180%;">Continuation Passing Style</span><br /><br />Parrot doesn't use stacks for it's control flow. Instead, it uses continuations. It's beyond the scope of this post to really talk about the differences and nuances of each. Instead of being stored on the system stack, continuation objects form a linked list (actually, more of a tree or graph) in the heap. By doing this, continuations aren't automatically cleaned up when they are invoked, and we can reuse them for things like loops, coroutines, closures, and all sorts of control flow optimizations and other fun things.<br /><br /><span style="font-size:180%;">Conclusion</span><br /><br />That's a quick overview of the C system stack. For more information, I've contributed to a book on Wikibooks called <a href="http://en.wikibooks.org/wiki/X86_Disassembly">x86 Disassembly</a> that talks more about the translation from assembly language back into C code. It covers function calls and stack frames in far more detail then I could in a single blog post. Of course, I would be happy to post more if people still have questions about it all.<br /><br />In Parrot, it's difficult to think of control flow as a unified thing. We either think of PIR control flow or C control flow, both of which are very different from the other! We can, if we need to, convert PIR down to C code, and from there convert to assembly or machine code too. It's all equivalent and interrelated,
                <div class='old-blogger-comments'>
                    <h2 class='old-comment-header'>Comments</h3>
                <div class='blogger-comment-div'>
                <p class='blogger-comment-body'>
                    Is it possible to find the address of the caller function(address as in address of the function and not the return address) in C..btw nice post.<br /><br />-Niks
                </p>
                <div class='blogger-comment-author-div'>
                    <span class='blogger-author-sig'>Anonymous
                    <span class='blogger-comment-datestamp'>
                        10/23/2009 5:13:37 AM
                    </span>
                </div>
            </div>
            <div class='blogger-comment-div'>
                <p class='blogger-comment-body'>
                    Thanks! In a general sense, it's not really possible to find the address of the calling function. At least, it's not possible if you don't know which function it is.<br /><br />In C, function names are all pointers. So if we have<br /><br />int foo(void){}<br /><br />Then the identifier "foo" is a pointer to that function. So, if we know that "foo" calls "bar", then bar can call "foo()", etc.<br /><br />One thing you could try on some architectures, if you want to get really tricky, is this:<br />1) Find the return address on the stack<br />2) Take a pointer to that location and start looping through memory until you find the first instance of the instruction "push ebp"<br />3) In a non-optimized binary on x86 using normal calling conventions this SHOULD be the address of the function.<br /><br />Some systems also have libraries that enable backtracing, so you may be able to get access to that and find out that way.
                </p>
                <div class='blogger-comment-author-div'>
                    <span class='blogger-author-sig'><a class='blogger-author-uri' href='http://www.blogger.com/profile/16207472474429254890'>Whiteknight</a>

                    <span class='blogger-comment-datestamp'>
                        10/23/2009 8:32:31 AM
                    </span>
                </div>
            </div>
            </div>
