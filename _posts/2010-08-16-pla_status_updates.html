---
layout: bloggerpost
title: PLA Status Updates
publish: true
categories: [Parrot, Parrot-Linear-Algebra, Rakudo]
---

On Friday night we dropped the kid off with his grandparents for a sleepover. With the apartment to ourselves, my wife and I did what we've been wanting to do for months: she went to bed early and I stayed up to program. I started making some real progress in Parrot-Linear-Algebra, and also uncovered some interesting bugs which needed to be fixed.<br /><br />I added a short file for adding PLA support to programs written in NQP. The file, <a href="http://github.com/Whiteknight/parrot-linear-algebra/blob/master/src/nqp/pla.nqp">pla.nqp</a>, can be included into an NQP program like this once it's installed:<br /><pre>INIT &#123; pir::load_bytecode("pla.pbc"); &#125;<br /></pre>That file loads the PLA binary library, stores a global reference to the library, and registers the type names with P6metaclass. That done, you can start writing more natural-looking programs in NQP. I updated the <a href="http://github.com/Whiteknight/parrot-linear-algebra/commit/5ec59719855c180505526d21148836a14bd6a461">Gaussian Elimination </a>example I wrote a few weeks ago to use this new bootstrap file (and some new methods I added), which means the example can now run without Kakapo or any other dependencies.<br /><br />Next up, I started prototyping bindings for the library for Rakudo. These are still preliminary, but I also have a working example of using numerical matrices in Rakudo. Within the next few days I will probably create a complete module for Rakudo (Math::LinearAlgebra, or something like that). I'll post more details as I do more work on it.<br /><br />I added a new item_at method which returns and optionally sets a value at given coordinates in a matrix. This method is common to all my core matrix types. The list of common methods for these matrix types is:<br /><br /><ul><li>resize() : pre-allocate size for the matrix, growing (never shrinking) it to hold a certain size</li><li>fill() : Fill a matrix, or a region of a matrix, with a constant value. Automatically resize if necessary</li><li>transpose() : Transpose (swap rows with columns) the matrix lazily</li><li>mem_transpose() : Eagerly transpose the actual memory contents</li><li>iterate_function_inplace() : Execute a function for every element of the matrix, replacing that element with the function result</li><li>iterate_function_external() : Execute a function for every element of the matrix, creating a new matrix with the results. This is similar to Perl's map function.</li><li>initialize_from_array() : Insert values into the matrix from an array</li><li>initialize_from_args() : Similar to the _from_array variant, but initializes the matrix using elements from a slurpy argument list</li><li>get_block() : Return a block, or "submatrix" from the matrix</li><li>set_block() : Set a block in the matrix</li><li>item_at() : New this weekend, gets or sets a value in the matrix at the specified coordinates</li></ul>There are maybe a handful of other methods I would like to add, but in terms of the core types, this is the standard API (plus a series of VTABLE calls, which are standard). For mathematics types I also have GEMM (the BLAS-based matrix multiply operation), and elementary matrix operations (add rows, swap rows, scale rows). This is not a shabby interface at all, and can start to be used for some real-world applications.<br /><br />This weekend I also started seeing some very weird errors in the PLA test suite. Tests were running fine, but I was seeing exceptions (and, in one case, a segfault) occur after all tests had passed. This sounded very <a href="/2009/07/11/the_bugs.html.html">similar to another problem I've seen</a> in the past. Here's the test that set it off. Can you spot the problem?<br /><pre>method test_METHOD_iterate_function_inplace_TRANSPOSE() &#123;<br />    my $m := self.fancymatrix2x2();<br />    $m.transpose();<br />    my $n := self.matrix2x2(self.fancyvalue(0) * 2, self.fancyvalue(2) * 2,<br />                            self.fancyvalue(1) * 2, self.fancyvalue(3) * 2);<br />    my $sub := -> $matrix, $value, $x, $y &#123;<br />        return ($value * 2);<br />    &#125;;<br />    $m.iterate_function_inplace($sub);<br />    assert_equal($m, $n, "external iteration does not respect transpose");<br />&#125;<br /></pre><br />What's maddening is that this test has been a problem for <i>months</i>, but never caused a failure. It was silently wrong, probably since the day I wrote it.<br /><br />See it yet?<br /><br />The problem is that return statement. What should happen is this: The pointy block creates an anonymous subroutine, which I pass to the iterate_function_inplace method. The method should loop over ever element in our matrix and call that pointy block for each one. The result should be the same matrix with every element multiplied by two.<br /><br />What actually happens is this: the iterate_function_inplace method, in order to call the callback, must recurse on the C stack into a new runloop function. The pointy block executes in this <i>inferior runloop</i>. However, where things get weird is that return statement. In NQP, returns are performed by constructing and throwing control exceptions. In the case of the pointy block (and I'm not sure whether or not this is a bug), the return statement jumps to the return handler for the test_METHOD_iterate_function_inplace_TRANSPOSE() function, not the anonymous sub.<br /><br />The sub executes after having only called the callback once, it never hits the final assertion (which, it turns out, would have failed). Control flow continues inside the inner runloop until the end of the test program, then the C runloop function returns, tries to continue executing from that point, and things go to hell.<br /><br />The solution is really quite simple. Change this:<br /><pre>my $sub := -> $matrix, $value, $x, $y &#123;<br />    return ($value * 2);<br />&#125;;<br /></pre><br />into this:<br /><pre>my $sub := sub ($matrix, $value, $x, $y) &#123;<br />    return ($value * 2);<br />&#125;; <br /></pre>Problem solved, and now more tests are legitimately passing.<br /><br />It's been a productive couple of days in PLA, and I'm hoping I can keep this momentum up in the days ahead. I need to finish implementing my GEMM wrapper for ComplexMatrix2D, and then get started on the Linear Algebra module for Rakudo.
                <div class='old-blogger-comments'>
                    <h2 class='old-comment-header'>Comments</h3>
                
<div class='blogger-comment-div'>
    <a name='8341717429511901072'></a>
    <p class='blogger-comment-body'>
        That looks normal. In Perl 6, which is where NQP got this behaviour from of course, pointy blocks don't catch return exceptions. They're kind of lightweight subroutines like that. Otherwise, for and while loops would catch return exceptions...
    </p>
    <div class='blogger-comment-author-div'>
        <span class='blogger-author-sig'><a class='blogger-author-uri' href='http://matthewwalton.myopenid.com/'>mathw</a>
</span>
        <span class='blogger-comment-datestamp'>
            <a class='blogger-comment-link' href='{{ post.url }}#8341717429511901072'>
                8/17/2010 5:18:31 AM
            </a>
        </span>
    </div>
</div>
</div>
