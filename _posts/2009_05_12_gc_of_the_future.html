---
layout: bloggerpost
title: GC Of The Future
---

With Parrot's GC API cleaned up a little bit, we can really put some serious thought into what we want to do with that system in the future. Obviously we're looking into creating new cores. Our current GC core is a simple stop-the-world mark & sweep collector. It's not fancy by any stretch, and it's a performance killer, but it works pretty reliably. Here are some things that we will want to look at in the coming months and years for the GC:<br /><br /><font size="5">Malloc Allocator<br /><font size="3">Take a look at the file <a href="https://trac.parrot.org/parrot/browser/trunk/src/gc/res_lea.c">src/gc/res_lea.c</a> and some of the discussion in <a href="https://trac.parrot.org/parrot/ticket/655">TT #655</a> for background. The malloc-based allocator doesn't use pools to allocate and manage memory, instead providing a thin layer over custom malloc calls to do the work. This saves a lot of Parrot-side code and effort: No compacting memory pools; no merging, initializing, or managing sized header pools; etc. It's an interesting idea although I don't think it's going to be part of Parrot's long-term plan because of performance issues in repeatedly calling malloc to let the OS manage our memory in small chunks. It's certainly worth looking into, especially since I think the fundamentals of this core could be used to get the <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">Boehm collector</a> working with Parrot in the near term.<br /><br /><font size="5">Ordered Destruction<br /><font size="3">This is on the long-term roadmap (not slated until <a href="https://trac.parrot.org/parrot/ticket/607">Parrot 3.6</a>) but sometimes feels like it's needed more urgently then that. Basically, we run into situations where child objects are destroyed after their parent objects, which causes all sorts of mismatched pointer hillarity. We've taken a lot of steps internally to hide this problem and to work around it, but that's more of a band-aid over the wound then a real solution. It's worthwhile considering what it would take to enforce proper ordering of object destruction, and what interface we would use for an object to declare it's dependencies. Not every time that PMCs point to each other do we have an ordered dependence between them. As an example, we could destroy a CallSignature PMC without having to first destroy the ResizablePMCArray PMC that contains it's arguments first. However, we generally do want to destroy the outstanding Exception PMCs before we destroy the Scheduler PMC that they rely on. So what we need first is a sane way to mark relationships between PMCs, and then we need a GC capable of respecting those relationships.<br /><br /><font size="5">Compacting/Copying Collector<br /><font size="3">Also on the long-term roadmap, <a href="https://trac.parrot.org/parrot/ticket/616">scheduled for Parrot 3.0</a>, is that idea of having a compacting/copying collector. In most Parrot GC cores, memory is allocated in large chunks called arenas. Arenas are structured into linked lists in "pools". Each pool contains a number of arenas, and is only responsible for items of a given size. So the PMC pool only contains PMC objects, the STRING pool only contains STRINGs, etc. When the pool uses up all it's memory, it allocates a new arena from the system. However, it never frees unused memory back to the OS.<br /><br />As headers are allocated from the arenas, we end up with a mixture of short-term and long-term objects. We end up with long-lived objects throughout the various arenas, and we are inable to get an entire arena that is completely empty so we can free it. We probably could, but it would take effort to scan through the arena to ensure that it is empty, and since the answer is usually "no" we don't even try. However, if we could compact the pool, by moving all PMCs into a few arenas, we could free the remainder to the OS. The problem of course is that suddenly our objects are moving and pointers get out of date and need to be updated.<br /><br />These are the three big GC-related items on the horizon, and I'm sure new ideas will pop up as well.<br /></font></font></font></font></font></font>