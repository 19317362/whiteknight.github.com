---
layout: bloggerpost
title: The Fitness of Parrot as a Target Platform
---

In response to the <a href="http://wknight8111.blogspot.com/2010/05/bright-blue-yonder.html">blog post I wrote the other day</a>, I received <a href="http://wknight8111.blogspot.com/2010/05/bright-blue-yonder.html?showComment=1274442384238#c4576637928891075936">a very poignant question</a> regarding Parrot's stability as a target for HLL compilers. Since the comment was anonymous and I can't ask permission, I'm going to repost a portion of it here:<br /><br /><blockquote>However to be honest, its scary that over the last 10 years so much was  done and discarded and is being rewritten. I agree with the "throw away  the first" reasoning but that is something I would expect in a 2-3 year  project not a 10 year old project.<br /><br />Could you comment on the risk  associated with for a HLL project that starts to build on Parrot with an  ETA of say 1 year? Can it be said with a reasonably level of certainity  that whatever sub-projects (JIT, treads etc.) are added to Parrot now,  they will take an evolutionary approach rather than being scrapped and  rewritten?<br /><br />My intent is not to put down Parrot as I really want  to use it but I want to voice my fears and hope to understand the  parrot-dev perspective on making Parrot a stable (for some definition of  stable) platform to build on.</blockquote>This really is two questions rolled into one:<br /><ol><li>Parrot has been in development for about 10 years, why are these big changes being made so late in the project?Â </li><li>Are these big changes going to affect the stability of the external API, and is Parrot a stable, reliable platform for HLL designers?</li></ol>I'll try to tackle these two separately.<br /><br />The 0.0.1 release of Parrot was cut in September 2001, according to <a href="http://trac.parrot.org/parrot/browser/trunk/docs/parrothist.pod">documentation in our repository</a>. I don't know much about the early history of the project; I've only been a Parrot contributor for about <a href="http://wknight8111.blogspot.com/2008/02/yay-im-being-helpful.html">two and a half years now</a>, about one fifth of the total life of the project. Looking through the <a href="http://trac.parrot.org/parrot/browser/trunk/NEWS">NEWS</a> entries starting back at 0.0.2, it does look like things were moving at a rapid pace back in 2001 and so maybe Parrot should be a lot further along than it is now.<br /><br />There are a few responses to this. The obvious ones: Volunteer developers are a limited resource, and Parrot is an enabling technology so many developers have been focusing their efforts outside the core (HLL compilers, libraries, programs written using both of those, etc). Core development effort and HLL compiler development effort are  certainly not directly transferable, but in the early years there was a  lot of cross-work among the central developers, and this did play a factor.  There are less obvious reasons, such as attempts to support various platforms (Parrot has supported or attempted to support several architecture and compiler combinations, some of which were exotic even 10 years ago), attempts to improve performance throughout (sometimes prematurely), and the fact that the NEWS file is misleading because the early "action-packed" releases that seem to show a high development velocity were not time-based releases and often represent several months of work. Hell, there were only 6 releases in all of 2003 and 2004 combined, but the NEWS entries for those releases don't look any more impressive than the <a href="http://wknight8111.blogspot.com/2010/05/parrot-240-sulfur-crest-released.html">news release for 2.4</a>. The pace of development is certainly not constant (though I would say it is increasing) and while 10 years looks like a lot, it's 10 years of inconsistent development time from contributors with other things going on as well. <br /><br />The biggest factor to keep in mind is that Parrot development from 2001 until 2010 <i>didn't happen in a straight line</i>. Parrot started out as simply the internals engine for the Perl6 compiler and grew to become larger than that. Along the way a lot of designs and plans were hammered out, then thrown away entirely. As I mentioned last time however, there isn't a whole hell of a lot of prior art in the area of dynamic language VMs; guesses were made and some of them ended up being wrong. <br /><br />We could have declared Parrot more or less "complete" some time ago and shipped a program that was known to have some serious flaws. Instead what we've been doing, and what I think is the more responsible course of action: fix it until it is correct. So to answer the first question: yes it's been 10 years, but Parrot isn't perfect yet and we are going to continue working on it until it is, <i>however long that takes</i>.<br /><br />The second question can itself be decomposed into several parts: Will things that I rely on change? If so, how quickly will they change? Will the work I do now need to be thrown out when the next big feature set lands? Is Parrot mature enough for me to build on top of it a software project that I want to lead into maturity? These are all good questions, and very concerning for HLL developers. The answer isn't clear-cut, but I will try to explain it as well as I can.<br /><br />The most important point I can raise when tackling this question is to mention <a href="http://trac.parrot.org/parrot/browser/trunk/docs/project/support_policy.pod">our support policy</a>. Our support policy, which I have complained about as being too strong, goes something like this:<br /><ol><li>We have 4 supported releases per year, every 3 months. We support these releases, including bug fixes, until the next supported release comes out. HLL compilers and other external projects are highly encouraged to target these supported releases (many do not, but they do so at their own risk).</li><li>We have a defined external API which cannot be changed without notice. A deprecation notice for any change to any externally-visible feature or behavior must be included in a supported release before that interface can be changed or removed. Assuming you target supported releases as suggested in #1 above, this means you have 3 months of prior warning to prepare your project before disruptive changes to Parrot are made.</li><li>New features that are added will be tagged "experimental" so projects can examine them, provide feedback, and get an idea of where things will be going in the future. If people start relying on experimental features and new problems aren't created, they tend to stay around. </li><li>Not quite part of the policy, but still relevant: When we cut releases, or change features, we try to do extensive testing in HLLs and external projects. Where problems are found, we typically try to either offer fixes or workarounds.</li></ol>It's interesting to note that many of our most disruptive changes in recent months were actually driven by the HLLs and external projects themselves, as fixes to bugs or longstanding problems. It's also worth mentioning that when the question is raised most HLL developers seem to want Parrot to make fixes and improvements more rapidly than it has been doing.<br /><br />Another part of the question is whether the new features and things that we will be adding/changing in coming months will be gradual and be able to be inserted non-disruptively into existing software projects. Let's give a quick rundown of some systems that could be seeing major changes in the next couple months:<br /><ol><li><b>GC</b>: GC is a very internal thing, when it works properly, you don't even need to know it exists. Any changes here, so long as they don't introduce bugs, will be invisible to the HLL developer, and will only serve to improve performance (or, improve it under certain workloads, depending on algorithm).</li><li><b>JIT</b>: In the past the JIT system was separate, and you needed a separate command-line switch to activate it. In the future, I'm hoping we get a trace-based system that kicks in automatically when a need is detected. JIT, like GC, shouldn't change execution behavior, only performance, so changes here should be invisible to the HLL developer.</li><li><b>Threads</b>: We don't really have a good, working, reliable threads implementation now and HLLs are generally not using them. Anything we add/change/fix will be as good as a newly-implemented feature and can be added post-facto by HLL developers with no stress.</li><li><b>NCI</b>: This mostly affects users of external libraries, and writers of interfaces to those projects. Improved NCI gives us improved access to more libraries. The interface here may change in a disruptive way but, I hope, this won't be a huge issue to most projects</li><li><b>Packfiles</b>: Packfiles aren't really portable now, so people haven't been using them to their potential. In any case, Packfile structure and handling are mostly transparent to the HLL developer. In the future what we will see are better usage patterns, improved performance and decreased bug volume, at no expense to the HLL developer.</li><li><b>PCC</b>: We have a pretty extensive library of tests for PCC behavior and a defined standard inferface that won't be changing any time soon. Sure, the internals may change (hopefully become faster) and new features will be added, but exising code will not notice.</li><li><b>PASM</b>: We're looking to add a suite of optimizations to PASM. These optimizations will likely be opt-in initially, so absolutely nothing changes for HLL developers who don't want them. If you do want them, your programs will probably only get faster at runtime at the cost of some additional processing in the compiler. This is a standard and non-exciting trade-off that most good compilers offer to their users.</li></ol>In summary, Parrot is a good, stable platform for HLL developers to use. Yes there are big changes planned to the internals of the VM, but most of them are going to bring big improvements to the compilers and library projects that run on top of Parrot, without affecting the externally-visible interface much and without bringing new problems. That really is one of the driving benefits of a VM system like Parrot: Write the improvement once and get the benefits everywhere. The interface is in flux, but changes happen slowly and with plenty of prior warning (and support, where support is needed). As the big systems in Parrot get fixed, things will get even more stable and the benefits will become even more apparent.<br /><br />I hope that helps answer some concerns.
                <div class='old-blogger-comments'>
                    <h2 class='old-comment-header'>Comments</h3>
                <div class='blogger-comment-div'>
                <p class='blogger-comment-body'>
                    Thanks for the detailed response to my (anonymous ;)) comment Whiteknight. It does indeed answer my concerns and I feel more comfortable committing to Parrot for my project.
                </p>
                <div class='blogger-comment-author-div'>
                    <span class='blogger-author-sig'>Anonymous
                    <span class='blogger-comment-datestamp'>
                        5/21/2010 12:59:55 PM
                    </span>
                </div>
            </div>
            <div class='blogger-comment-div'>
                <p class='blogger-comment-body'>
                    have you considered using the JVM?
                </p>
                <div class='blogger-comment-author-div'>
                    <span class='blogger-author-sig'>Anonymous
                    <span class='blogger-comment-datestamp'>
                        5/21/2010 2:21:03 PM
                    </span>
                </div>
            </div>
            <div class='blogger-comment-div'>
                <p class='blogger-comment-body'>
                    i would prefer to use parrot or mono over the JVM, the jvm to me scream pain lol. i think interoperability of languages like jython and java on the jvm i've heard is painful. And i would trust parrot from all the playing i've done with it, mainly the NCI annoys me i would like to see parrotvm to be embedded easier and more dynamically. I was going to apply for parrot for my gsoc but got on to work on one of my old projects within GCC. I think PIR and PASM have been well designed i would like to see how the jit is going to fit in because it wont be easy but i am looking forward to see the development of lorito within parrot its pretty exciting... ( i dont get out much lol j/k). Overall parrot is cools its s shame its taken 10 years but when its come out of the guts of the perl6 compiler it can happen i guess. Plus building a virtual machine like this when changing parts of code can really affect the whole running of the system so it takes alot of time to get the whole thing running on the right track, when you have to worry about GC the runtime the jit the input's PIR/PASM etc...
                </p>
                <div class='blogger-comment-author-div'>
                    <span class='blogger-author-sig'><a class='blogger-author-uri' href='http://redbrain.co.uk'>redbrain</a>

                    <span class='blogger-comment-datestamp'>
                        5/21/2010 3:13:08 PM
                    </span>
                </div>
            </div>
            </div>
