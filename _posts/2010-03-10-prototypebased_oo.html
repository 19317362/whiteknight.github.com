---
layout: bloggerpost
title: Prototype-based OO
---

I was following along with a conversation on IRC between allison and a newcomer (at least, a nick I don't remember seeing previously) about using a prototype-based OO model in Parrot. This got me thinking: Why doesn't Parrot supply a prototype-based object model? I'm not saying that we should replace our existing object model which, despite it's warts, is both functional and heavily entrenched. Instead, I'm thinking we add a prototype model in parallel, and allow users to pick and choose which they want to use for their systems.<br /><br />Disclaimer: Yes, I know the current development priorities are bugfixes and support for the upcoming Rakudo* release. No, I'm not planning to work on this project until after that milestone. But, that doesn't mean we can't think about it!<br /><br />Allison suggested that having a prototype-based OO model included in core Parrot would be a good thing, and said I should start drafting ideas in the object model PDD about it. Before I do that (unless somebody beats me to it!) I want to start airing out some ideas here.<br /><br />In a class-based system, Class objects store information about objects of that type, and all objects of that class are typically isomorphic: They all share access to the same methods and same named attributes. If we change the class, all objects of that type immediately inherit those changes. Of course, Parrot's default object model doesn't allow much modification of the Class after objects have been created from it, but that doesn't mean no class-based systems do.<br /><br />In a prototype-based system, objects contain all their own metadata which is copied from a template-like prototype object. When we instantiate a new object from the prototype, the object gets a read/write copy of the hashes for methods and attributes. The only thing that is guaranteed is that at instantiation time the object is a faithful copy of the prototype. After that, the object and prototype can evolve independently: We can add methods and attributes to individual objects without modifying other objects created from the same prototype. In most cases, modifications to the prototype don't produce changes in the objects created from it after the fact.<br /><br />Short explanations aside, what would we want Parrot's version of prototype OO to look like? Ob viously it should integrate well with our existing object model, storing methods for the prototype in a NameSpace and associating Prototypes with Namespaces uniquely. Also, we would want to store prototype objects in the interpreter's class hash along with the "normal" class objects. I suspect we would want Classes to be able to inherit from prototypes and vice-versa (though talking about "inheritance" in a prototype system is a little different from how it is used in a class-based system). Objects made from prototypes should allow VTABLE overrides for all necessary VTABLEs, including some of the class-related ones that Object doesn't implement (addattribute, etc).<br /><br />Javascript uses a very fluid model where "methods" are really just like other attributes except they store a code object instead of a data object. This would imply that a prototype-object following this model would essentially be a hash internally. I'm not familiar with too many other prototype-based systems, but I suspect this is not always the case.<br />