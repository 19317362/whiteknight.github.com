---
layout: bloggerpost
title: Work on the IO System
---

I spent several hours in the air between PA and TX when I traveled there for business, and I used that time to really dig through the code for some Parrot subsystems that I hadn't been too familiar with before. I dug through the stacks system, which I had done some cleanup work for in the past but never paid much attention to, I looked through the runcores, the scheduler, the NCI system, and finally the IO system.<br /><br />People who have read my blog this month will know that I've had a lot to talk about recently with <a href="http://wknight8111.blogspot.com/2009/05/asynchronous-io-in-parrot.html">Parrot's IO system</a>. Specifically, implementing the asynchronous version of that subsystem is a major project on my todo wishlist that I want to work on before Parrot 2.0 is released next year. However, as I read through the code and the relevant PDD, I realize that this system is not nearly so far along as I thought it was, and there's some major groundwork to do before I can implement the AIO system.<br /><br />The Parrot IO system, like many systems in Parrot, was designed by people with a lot of talent and a lot of ambition. The designs for many system are grandios, sometimes bordering on the realm of "too good to be true". However, this kind of thinking makes sense when you figure that the performance and feature set will be a major limiting factor for all programming languages and programs written in those languages that are running on top of Parrot. Every subsystem in Parrot needs to implement at least as many features as the most taxing language demands, and since every language excels in different things we need everything to be as good as possible. The IO system is no exception, and while the design doesn't strike me as being the absolute ultimate in terms of capability or performance, it's certainly quite ambitious nonetheless.<br /><br />Parrots IO system, as it has been designed, has three major features:<br /><ol><li>Actual IO streams are encapsulated by various PMC types, that implement various capabilities (FileHandle PMC, Socket PMC, etc)</li><li>The IO system is built in layers, where each layer implements a subset of the complete IO API, and the layers in use can be modified dynamically and transparently to handle different situations. The layers get composed together to form a single complete API.</li><li>The IO system has an asynchronous component, in addition to a "normal" blocking one. It uses a special request PMC type to manage asynchronous requests.<br /></li></ol><br />Of these three primary design objectives, only #1 is actually implemented right now, from what I can see in the code. The next step I think is to get the <a href="https://trac.parrot.org/parrot/ticket/669">layering system working</a> like expected, and then we can put together the AIO system. That's cool too, I do enjoy a challenge. Plus, I have a significant programming project at work that contains a pretty robust layered asynchronous IO system, so I feel like I'm in the zone to get that kind of work done right now.<br /><br />The IO layering system that's proposed in the PDD is a little bit interesting, and I'm not sure I understand it correctly. When I think about a layered system I envision a linked list, where functions in each layer pass their "signals" down to the next layer in the chain. So calling the "print" opcode passes the data to the top layer, which pushes it to the next layer, and so on and so forth until the data reaches the termainal or "bottom" layer, which the pushes the data out to it's final destination. The PDD however says this about how layers will be ideally managed:<br /><blockquote><br />Currently, the Parrot I/O subsystem uses a per-interpreter stack to<br />provide a layer-based approach to I/O. Each layer implements a subset of<br />the ParrotIOLayerAPI vtable. To find an I/O function, the layer stack<br />is searched downwards until a non-NULL function pointer is found for<br />that particular slot. This implementation will be replaced with a<br />composition model. Rather than living in a stack, the module fragments<br />that make up the ParrotIO class will be composed and any conflicts<br />resolved when the class is loaded. This strategy eliminates the need to<br />search a stack on each I/O call, while still allowing a "layered"<br />combination of functionality for different platforms.<br /></blockquote><br />This description doesn't really jive with me, and maybe I'm misunderstanding it. The purpose of the IO stack, in my mind, isn't just to provide a lookup to find the first non-null function, but instead to allow dynamic combinations of functions that are each defined atomically.  So instead of having a system with a single layer that "does file IO on windows" or "does socket IO on Unix", we would have layers that "does line buffering", "does escaping", "does file writing" and "does file writing on windows", or something like that. The layer to do buffering passes the buffered data to the layer that does character escaping, which passes the data to the generic file interface, which finally passes it to the windows-specific interface. Then, when we don't want buffering we can just remove that layer, instead of having to set an "is buffered" flag and check it for every request.<br /><br />My program at work, for instance, has a bottom layer that communicates with a serial port, a  set of layers that enforce specific pre-set connection profiles, a layer that does buffering, a layer that translates user input commands to binary commands and vice-versa, etc. Then, when I need to turn on or off a particular feature, I simply remove the respective layers from the stack and everything else proceeds like normal. In short, I think that IO layers should not be composed together in the same way that roles are composed into classes, providing functionality that doesn't already exist and reducing to either-or in the event of a conflict. Instead, I think they should be added together so you get the affects of layer A and layer B simultaneously.<br /><br />If NULL pointers in layers was a problem we could definitely "compose" layers together in such a way that we flatten out the NULL values and are left with compact arrays of function pointers that can be iterated over. That kind of composition makes perfect sense to me in this context. If we do compose layers like the PDD suggests, by combining non-overlapping layers and "resolving" conflicts in an either-or way, we lose the ability to combine together unrelated functionality for the same API functions. Maybe I'm just not understanding it however.