---
layout: bloggerpost
title: Using Contexts from PIR
---

In my last post I talked about how Contexts might be adapted to fit in the PMC VTABLE interface. I hinted also that this work would make contexts available at the PIR level, not just for read-only introspection, but also direct manipulation. A PIR-facing way to manipulate contexts could usher in a pretty radical shift in the way Parrot is used by it's users. There is also the cool idea that it would make possible new coding methodologies that we haven't even thought about yet.<br /><br />As a quick recap, Context objects are pretty central to the way that Parrot performs and manages subroutine invocation. A Context contains some of the following data items:<br /><ol><li>The register set available in that context (the number of each type of register, and the contents of each register of each type)</li><li>The relationship of the context to other contexts (The calling context, and the "outer" context in the case of closures)</li><li>The currently active Sub and Namespace, the currently associated LexPad, the current invocation object, etc</li><li>The list of local handlers</li><li>Flags for the types of errors and warnings that should be reported in that context</li></ol>Now that we know that list of data items, let's consider the idea of two new opcodes: invoke_with_context, which works like "invoke" but takes a Context PMC as well to forcibly execute the Sub in the specified context, and "switch_context", which enables you to swap out the current Context of the Sub with a different one. These are just two possibilities, but they are quite interesting indeed! Consider some other ideas:<br /><br /><font size="5">Loop optimizations</font><br />Calling the same subroutine with an identical Context saves in having to create a new context for each call, and saves on having to re-pass parameters: We simply pass the parameters into the context once, and then keep them there for subsequent calls. Huge optimization potential here.<br /><br />Consider this loop, written out in expanded PASM-like syntax (and notice that I am ommitting some steps and not writing this perfectly):<br /><pre><br />i = 1<br />loop_top:<br />set_param foo<br />set_param bar<br />set_param baz<br />set_param i<br />invoke 'my_sub'<br />inc i<br />if i <= 100 goto loop_top </pre><br />Each call to <code>my_sub</code> would create a new context and passes the variables foo, bar, baz, and i. With a Context PMC, we could write something like:<br /><pre><br />i = 1<br />mycontext = new 'Context'<br />mycontext[0] = foo<br />mycontext[1] = bar<br />mycontext[2] = baz<br />mycontext[3] = i<br />loop_top:<br />invoke_with_context 'my_sub', mycontext<br />inc i<br />mycontext[3] = i<br />if i <= 100 goto loop_top </pre><br />Quite a bit smaller and speedier in the loop!<br /><br /><font size="5">Simplified Currys And Default Parameter Values</font><br />We could associate a context with a subroutine in order to specify default parameter values:<br /><pre><br />mycontext = new 'Context'<br />mycontext["NamedParam"] = 5<br />set_sub_context 'my_sub', mycontext<br /></pre><br />In this example, when we call the subroutine "my_sub" the named parameter "NamedParam" will have a default value of 5. Of course, once we change the value in the subroutine we would have to reset the default value, so that's a mechanism that needs a little bit more thought (but is very doable!). To really expand this idea, consider being able to access and modify the containing context of a capture, after that context has already "disappeared".<br /><br /><font size="5">Some Other Ideas</font><br /><ol><li>In a tailcall we already cache and reuse the RetContinuation. Imagine if we could simply reuse the existing context as well. It's like inlining, where we wouldn't have to pass parameters because all the parameters are already in the context to be accessed.</li><li>Ability for a context to switch, at runtime, what namespace it is operating in, and which object is treated as the "self" invocant.</li><li>Ability to pause and store execution by saving the current Context and swapping it out for a different one. This would be quite interesting not only implement a fork() function, but also for being able to pause and resume a single program instance between multiple Parrot instances.</li><li>Being able to modify the internal state of a Coroutine between calls. This would enable us to, for instance, modify the parameter values of a coroutine without having to terminate it and re-call.</li><li>Lambda abstraction: We gain the ability to separate the Sub object from it's operating state, which would allow us to arbitrarily execute that Sub in any context. Think of this as a way to do to individual Subs what Roles do for Classes (runtime composition). </li><li>Alternate calling conventions: Imagine a separate way to call functions where instead of passing parameters and letting Parrot process them, we pre-populate the register set with the parameter values and pass that instead. It would allow calling conventions to be redefined at the PIR level, without having to create an override of the Sub or Multisub PMCs at the C level.</li></ol>A lot of this is speculative, and a lot of it is obviously dangerous because it gives us the ability to badly break encapsulation in a number of ways. I've purposely tried to include some of these dangeous ideas, to keep things in perspective. There's no saying that Parrot won't give you plenty of rope to trip yourself with, if that's what you choose to do. It would be interesting to see what other ideas people have about this, how people think that PIR-facing Context PMCs could be used for if they had an uninhibited introspection and reflection interface. What would you do with this power if you had it?<br /><br /><br />