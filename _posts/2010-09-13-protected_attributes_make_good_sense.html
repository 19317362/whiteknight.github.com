---
layout: bloggerpost
title: Protected Attributes Make Good Sense
---

A few days ago Moritz Lenz, one of the prominent members of the Rakudo Perl 6 team, wrote a <span id="goog_861287589"></span><a href="http://perlgeek.de/blog-en/perl-6/protected-attributes-make-no-sense.html">post about the "protected" modifier, and how it makes no sense<span id="goog_861287590"></span></a>. I've stewed over it for a few days, and finally decided to write a response to it.<br /><br />First, the gist of Moritz's post: <br /><br /><br /><blockquote>In C++, you can declare an attribute or a method as "protected". Which means that it is private, but subclasses can still access them.<br /><br />This makes just as much sense as saying <em>you only get access to these attributes if you wear a funny yellow hat</em>.<br />...<br />However your users can not only instantiate your classes, but they can also inherit from them. Which means they can put a funny yellow hat on. There is no restriction as to who can inherit from your classes. Which makes protected attributes part of the public interface.</blockquote><br />In C++, as in any programming language, there is a difference between saying "this is what I do", and "this is how I do it." One of the huge benefits of object-oriented software is that objects can encapsulate a particular abstraction or particular behavior and be treated by the end user as a black box. So long as the object's public API doesn't change, users of that object should be able to stay blissfully unaware of changes to the object's internals. This is a good thing, and is something that should be prized. We want good, clear, simple, and stable public APIs. <br /><br />The difference between public and protected modifiers is a difference in thinking and a difference of purpose. The public modifier is an interface into "this is what I do", while the protected modifier is an interface for "this is how I do it". The public modifier allows other classes to delegate to our object to perform a specific task in a black-box kind of way. The protected modifier allows <i>subclasses</i> to perform the same kind of task themselves, with a much thinner encapsulation barrier to content with. With a properly-defined two-level API, we can cleanly abstract the interface from the implementation details, and give users clear options between using a class as-is to perform a specific task, or to override the behavior of that class to perform a different, albeit similar, task.<br /><br />Is it possible to write a sneaky subclass which does little besides providing transparent access to protected fields and methods? yes. Is it possible for me to write a disassembly routine that disassembles a private method from a third-party library, injects my own logic into it, and reassembles it back into a working binary? Also, yes. Does it mean that everything should always be public when, with enough know-how and effort, I can find ways to access it anyway? No.<br /><br />To complete Moritz's analogy, a private identifier is like saying that you can only access it if youÂ  <i>wear an extremely elaborate yellow hat with matching shoes</i>.<br /><br />What we're talking about here is really interfacing with third party code that you didn't write yourself. If you wrote the project and find yourself in need of a broader public API that you've written so far, it's easy enough for you to change your own code. A third party library has it's own internals and it's own encapsulation barrier. If your break it or abuse it, it's not likely that the third party will take too much pity on you when those details change and break your sneaky, abusive code. If you follow a nice interface you might qualify for all sorts of benefits from the third-party software provider: <i>help, support, and long-term API stability</i>. If you choose to go around the provided interface and use things in ways that they were never intended to be used, you may end up without these things. <br /><br />Plus, if you want to take all the protected fields and methods of the parent class and expose them as a public part of your own API, the onus now falls on you to maintain that API, even when the parent class changes. This can become a lot of extra effort for you, especially when those protected methods and properties were never designed to be elegant and powerful parts of a public API.<br /><br />Remember, there's always a difference between <i>this is the job I perform</i>, and <i>this is how you can perform that job yourself.<b> </b></i>On one path lies <i>delegation of responsibilities, stability, abstraction, and encapsulation</i>. On the other path lies <i>reimplementation, customization, and centralized responsibility</i>.<br /><br />These differences clear, remember also that the act of creating a subclass is a conscious decision. You don't read the documentation, look at the public interface, and call a protected method <i>on accident</i>. The public API is what people will see first and will attempt to use first. When that doesn't pan out (and it usually does, for sufficiently well-designed public interfaces), you can try alternate approaches. It's like using a cast in C:<br />In many cases it won't change the behavior of the generated machine code at all, but it does indicate to the compiler that you understand that you are playing with data in a weird way, and that you take responsibility for it. When something goes wrong, the compiler can point back to your code and say "see? You did this explicitly." Likewise, going through the effort to create a subclass and provide transparent accessors for protected details is a lot like an explicit declaration that "I know what I am doing, and I take responsibility for it". Maybe it's a little bit more verbose than it should be, but that's a matter of syntax and personal taste.<br /><br />That said, if you do come up with a legitimate and well-thought-out reason to enable public access to a protected detail, you should consider sending a feature request to the developer of the third-party library to have that included as part of the public API. Maybe the developer just never considered it. Maybe he could provide you a better workaround. Either way, I'm sure the feedback will be appreciated, if you're polite about it.<br /><br />Using a protected method is not just like using a public method while wearing a funny yellow hat. First, you're probably doing something a little bit differently from a normal user of the public API. Second, you're having to demonstrate some basic understanding of what you are doing, and take some personal responsibility for the results.<i></i> <br /><br /><br />Microsoft's managed C++ allows an "internal" keyword, which means that certain classes are not visible outside the CIL assembly, and therefore cannot be subclassed by external user code.