---
layout: bloggerpost
title: Problems with C#
publish: true
categories: [C#]
---

I've been using C# at my day job for some time now. When I first started there the place was a little bit disorganized and different projects were using different languages. I did some work in VisualBasic.NET, Perl, C++, and even a little Tcl. Luckily as the place grew we put together some standards, and now all our PC-side and server-side development is done in C#.<br /><br />Yes, I am deeply involved in Parrot, the dynamic language VM. Yes, C# is hardly a dynamic language (even with some of the new "dynamic" features that have been added in newer revisions). It seems little bit weird that I would be so enamoured with C#, but I am. In fact, I would venture to say that for Windows systems it is my development language of choice. I've heard decent things about Mono on Linux but never used it myself. On Linux, I think my development language of choice may still be C (or NQP!).<br /><br />However, despite my general happiness with the language there are some problems I have with it. Here are my nits with C#:<br /><br /><span style="font-size: x-large;">Constructors</span><br /><br />I feel like constructors aren't given a fair shake, and I have a few issues with their use. For instance, their use with generics is positively anemic:<br /><pre>public void Foo<T>() where T : new() &#123;<br />   T bar = new T(new Baz());<br />&#125;<br /></pre>The constaint "Where T : new()" only mandates that the type T has <i>any</i> constructor, but in my Foo method I specifically require it to have a constructor that takes a Baz. Generics are supposed to provide typesafety for cases like this, but it's extremely easy to compile a program with this kind of construct and not have any compile-time indication that the types are incompatible.<br /><br />And while we're at it, interfaces should be able to specify a list of required constructors. I'm constantly baffled by this omission, I run into problems from it on a regular basis, and I can't imagine why it wouldn't be possible.<br /><br /><span style="font-size: x-large;">Static Methods in Interfaces</span><br /><br />Speaking of interfaces, for the life of me I can't understand why interfaces cannot be used to specify static class methods and properties. I've seen dozens of half-hearted "explanations" for why we don't have this ability, and none of them compel me at all.<br /><br />Let me give an example from code I was working on this very day. I'm putting together an MDI application which can host a heterogenous collection of child forms. Different form types have different properties: Some are multiplicious. Some are "singletons", where only one child window of that type can open at a time. Some windows should start maximized, and some minimized. Some should open at program startup. Some of this information I need to have from the child form before I instantiate it, so it would be really nice to have a static method on the type that I can call to get this info. Basically, I want to do this:<br /><pre>private method ShowMDIChild<TForm>() where TForm : Form &#123;<br />  if (IsSingleton<TForm>() && this.SingletonCache.ContainsKey(typeof(TForm)))<br />    return;<br />  TForm form = new TForm(...);<br />  form.Show()<br />&#125;<br /></pre>The "..." above really is a variable list of arguments, since different types of child forms may want different argument lists to be created. Sure, I could have a large common list of arguments and force all my forms to implement the same constructor with some of the arguments treated as unused shims, but thats a huge hassle (and I can't specify that constructor in a common interface).<br /><br />One thing I can do, which is particularly ugly in my mind, is this:<br /><pre>public interface ISingletonMDIChild &#123;&#125;<br /><br />...<br /><br />private method ShowMDIChild<TForm>() &#123;<br />  if (typeof(TForm).GetInterface(typeof(ISingletonMDIChild).FullName) == null) &#123;<br />    this.ShowMDIChildSingleton<TForm>();<br />  ...<br />&#125;<br /></pre>And I think we can all agree that this is a hideous mess. Plus, it would require me to write up all sorts of stub interfaces and treat them like boolean class flags. I could use attributes, but the code to reflect over the class and iterate over attributes is even uglier (and <i>much slower</i>). We also can't always inherit from an abstract parent class because of C#'s restriction to single inheritance. What I want, in a nutshell, is a way to gather a standard set of metadata about classes of a related type in a clean way. I can't think of a better way to do this than static interface methods. I haven't heard any compelling arguments about why we can't do this, but I have heard a lot of half-hearted justifications for it.<br /><br /><span style="font-size: x-large;">Multiple Inheritance.</span><br /><br />Yes, it's messy. Sure the implementation would be a little bit messy and the coder would probably have to specify the resolution order manually. I don't care. I find so many cases in my day-to-day coding when judicious use of multiple inheritance would be a perfect solution to a problem, and the alternatives are hackish, ugly, and very difficult to maintain.<br /><br /><span style="font-size: x-large;">Type Switches</span><br /><br />Consider the case of a tree control which contains a number of objects of different types. Each TreeNode in the tree contains a reference to that object in the TreeNode.Tag property. When I right-click on different types of nodes I want to see different context menus pop up, depending on the type of the object at that node. That context menu should call methods on the parent form when clicked.<br /><br />One thing I could do is this:<br /><pre>ContextMenu menu = currNode.Tag.GetContextMenu();<br /></pre>But this solution requires the object to build the menu programmatically. To call methods on the parent form I need to do something ugly like pass a variable list of delegates to the object as callbacks, or pass a reference to the Form and make all my methods public, or something like that. Now consider the case where some of the nodes in the list don't have context menus, and some of them call a default version, and we quickly end up with very messy code. What I would really like to do is something like this:<br /><pre>switch (currNode.Tag is) &#123;<br />  case ClassFoo:<br />  ...<br />  break;<br />case ClassBar:<br />  ...<br />  break;<br />&#125;<br /></t></pre>I guess I could do:<br /><pre>switch (currNode.Tag.GetType().FullName) &#123;<br />  case "MyNamespace.ClassFoo":<br />  ...<br /></pre>But that's horrible and unmaintainable. Plus, it doesn't respect inheritance. I could do this:<br /><pre>if (currNode.Tag is ClassFoo) &#123;<br />  ...<br />&#125; else if (currNode.Tag is ClassBar) &#123;<br />  ...<br />&#125; <br />...<br /></pre>But that's horrible too. On the bright side this one does respect inheritance, but then again it is harder to maintain.<br /><br />An ability to do a switch statement, which lends itself naturally to multiple alternatives, with object type would be a huge benefit.<br /><br /><span style="font-size: x-large;">Switch Case Fallthrough</span><br /><br />And on the subject of the venerable switch statement, it kills me a little bit inside every time I try to implicitly fall through from one case to another and I get a compiler error about it. One forum post I saw actually suggested this gem to workaround the restriction:<br /><pre>switch (whatever) &#123;<br />  case 1:<br />    ...<br />  goto _2;<br />  case 2:<br />_2:<br />    ...<br />&#125;<br /></pre>Gag me with a stick, and deliver me from evil.<br /><br />This is a pretty small list of wishes and, except for the multiple inheritance thing, don't represent huge changes to the language. If anything I think they will make a few tasks much easier. You can complain about my contrived examples if you want.