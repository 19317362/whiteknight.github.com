---
layout: bloggerpost
title: Thesis Status
---

Gotten a lot of work done on my thesis recently. Most of the work at this point is just in writing code, so I've written a lot of it.<br /><br />The design, at the moment, consists of three large data structures, although two of them are going to be merged together. These two objects are going to be wrapped in a large interface class for easy access. The first object (hmodel) represents both an abstract processor hardware design, and an interface to an actual hardware design file for simulation and implementation. The second object (optstruct)  represents the design for the associated assembler. These two are non-orthogonal, in that some pieces of data overlap (machine code word formats, opcodes, etc). Integral to this relationship is the implementation of frequent sanity checks, to ensure that the overlapping data items are equal.<br /><br />The hmodel object interfaces with a Xilinx microprocessor model and a set of associated libraries. As changes are made to the object, changes are effected in the hardware model itself. The processor is broken down into 6 primary components: Instruction Fetch (IF), Instruction Decode (ID), Register File (REG), ALU,  IO Ports (IO) and Writeback (WB). For each component there exists a library of plug-in options to choose from. As options are set in the hmodel object, the libraries are scanned for components that match those values. If a match is found, that library component is put into the model. This interface is nearly complete.<br /><br />Here is a basic rundown of my progress:<br /><ul><li>Hardware and software design: 90%</li><li>Basic classes and interfaces: 90% (barring a partial rewrite)<br /></li><li>Component libraries: 30%</li><li>Graphical User Interfaces (GUI): 50%</li></ul>Once the classes and interfaces are complete, the GUI will fall into place very quickly. The component libraries are trivial once I have all my interface designs finalized, especially since I'm not optimizing them. Once I'm code-complete, I start on full testing and debugging, and then I need to prepare 3 physical hardware designs. Once the three processors are complete, I'm finished. At my current work pace, I expect to reach code-completeness within 2 weeks, including a substantial rewrite of some core components. Testing and debugging should last anywhere from a week to two weeks after that. With the system up and running, building the necessary processor models will be trivial.