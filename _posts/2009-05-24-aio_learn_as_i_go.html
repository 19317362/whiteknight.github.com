---
layout: bloggerpost
title: AIO&#58; Learn as I go
---

Yesterday I posted up my first prototypes of some AIO-related PMCs. It's still a rediculously early stage of development, and the code I have written is more exploratory and throw-away then anything. The purpose for doing this kind of development in a public branch is to get as much feedback on it at all stages as I can, to help me figure out the real way to move forward.<br /><br />Just this little bit of code has helped me immensely, and I think I have a few ideas about how to proceed from here in an orderly way. Some points:<br /><ol><li>I've decided to go with the POSIX AIO API on Linux, instead of using epoll like had been suggested to me by a commenter. I've been having a really difficult time finding reasonable documentation about epoll, and from what I see neither it nor poll do what I need them to do for this application.</li><li>The POSIX API doesn't require file descriptors for files be opened differently if they are intended for asynchronous use, but the Win32 IO API does require it. Plus, all the methods will be different for each. We need to know <font style="font-style: italic;">when the stream is opened</font> whether the stream will be used for synchronous or asynchronous operation.</li><li>There are two ways to differentiate. The first is to use a flag inside the stream PMCs to specify whether the stream is synchronous or asynchronous. We would need to specify when we call open, probably using a flag like "n" (non-blocking) or "b" (blocking, default). The other way would be to maintain two separate PMC types: FileHandle and AFileHandle, Socket and ASocket, etc. I'm not sure I like the second way as much, but through the magic of PMC subclassing, it shouldn't be too hard to make it work either. I think I will stick with the first option and use the flag.<br /></li></ol> I've already talked about some of the opcodes as specified in PDD22. The asynchronous versions of each are similar to the synchronous versions, except they take an extra callback PMC and return a status object. However, what to do about methods? So, to do an asynchronous read through a method, do we write this:<br /><br />$P0 = open "filename", "nr"   # n = non-blocking<br />$P1 = $P0.'readline'()             # $P1 is the status object<br /><br />In this case, open either returns an AFileHandle PMC, or returns a FileHandle PMC with the "async bit" set. Or, would we have to write something like this:<br /><br />$P0 = open "filename", "nr"<br />$P1 = $P0.'readline_async'()<br /><br />Where the "readline" method is always synchronous no matter what, and the new "readline_async" method becomes available for FileHandles that are async-enabled?<br /><br />I prefer the first idea for a few reasons. First, on Linux systems where file handles are not required to be opened with asynchronous capabilities, we could easily do something like this:<br /><br />$P0 = open "filename", "r"    # Notice, no "n"<br />$P1 = $P0.'read_async'()       # WTF? Not async FileHandle!<br /><br />This example would work perfectly on Linux, but would fail on Windows, and those kinds of differences in behavior between platforms should be invisible to the PIR user. We shouldn't even be allowed to call "read_async" on a non-asynchronous file handle, even if one particular platform doesn't make a difference between the two.<br /><br />Here is how AIO is going to work from the point of view of the PIR user:<br /><ol><li>You open a stream with a special flag, probably "n". Opens will happen synchronously, there isn't going to be an asynchronous version of the open opcode (it just doesn't make sense to me and I can't think of a good use case, especially for some streams).</li><li>With the returned filehandle object, you can call all the normal methods, "read", "readline", "write", etc. For asynchronous streams, these methods will return status objects. For synchronous streams these will return what you expect (strings for read and readline, integer bytecounts for write)</li><li>With the IO status object, you can poll it for status information, check it for errors, and get the return value once the operation has completed.</li><li>When we poll the IO status object, it requests the IO Poll object to start polling. The IO Poll object will iterate over it's list of requests, checking them each, and updating flags in the requests that are already completed.<br /></li><li>When we poll the IO request and it comes back positive, we run the associated callbacks, if any. Because Linux would need us to set a synchronization point anyway, it doesn't make sense for us to allow the OS to call callbacks asynchronously on all systems, we may as well do it manually when we poll.</li><li>In addition to manually checking status objects like this, we can have the scheduler do it too when it checks for pending tasks. This way we get callbacks to happen even if we never poll them manually.</li><li>At Parrot_exit time, when the interpreter is shutting down, we need to check for outstanding requests before we close, and make sure they all complete (or timeout) first.</li></ol>I'm going to start putting together an RFC on this topic for the rest of the Community to have some input on it. I'm going to propose a few changes to PDD22, and I hope to get a lot of feedback about that before doing anything too rash.<br /><br />