---
layout: bloggerpost
title: PIR2.0 Compiler
---

Following a discussion this morning about the PIR compiler, I think I have decided on a new project to focus some of my efforts on: a new assembly-level compiler for Parrot. We've already decided that we're not going to use this name, but until we think of something really creative, we're just calling it "PIR2.0".<br /><br />So what will this new compiler do that IMCC and PIRC do not do? What will the new language look like? What's the motivation for writing a new compiler when we have IMCC and PIRC available already?<br /><br />The problem with IMCC and PIRC is easy to spot: PIR. PIR is a lousy language. It's harder to parse than a more simple assembly language. It doesn't expose the full functionality of the underlying bytecode format. It tries to be more friendly to the average programmer than an assembly language is, but is nowhere near the level of friendlyness that even a C programmer would expect. PIR is the problem, and no matter how great your compiler for it is, it still needs to deal with all the warts of PIR.<br /><br />There are compromises to be made, of course. Allowing symbolic operators is nice, but increases parser complexity and requires us to make certain assumptions that "+" calls add_x_x_x, += calls add_x_x and so on. I generally would suggest that we disallow symbolic ops in the assembler. We can make up for this downside by improving flow control quite dramatically, improving variable and register use dramatically, and adding more flexibility in many cases. Here are some of my early syntax ideas that I'm thinking about, but I would like to open the discussion to a wider audience for more ideas:<br /><br />constant<ResizablePMCArray>{1, 2, 3, "whatever"} foo;<br />constant<Hash>{<br />constant initialize {<br />.pmc x<br />new x, "Hash"<br />set x, ["test"], "whatever"<br />return(x)<br />} bar;<br /><br />sub main anon load<br />"main"(pmc args) {<br />...<br />label(pmc a, pmc b):<br />}<br /><br />multi sub subid<"12345"><br />"baz"<String,_,_>(pmc a, pmc b, slurpy pmc c) {<br />lexical sub "baz_2" (pmc x) {<br />}<br />"baz_2"(a)<br />}<br /><br />method "fie"(named<"stuff"> pmc a, lexical named pmc b, named slurpy pmc c) {<br />lexical pmc x<br />lexical<"$_"> pmc y<br />dynamic pmc z<br />dynamic<"$outer"> w<br />...<br />}<br /><br />So this gives some of the ideas that I've been thinking of. I'm definitely focusing my efforts of ease of parsability and usability for the programmer. This is an <span style="font-style: italic;">extremely early</span> draft for what the syntax could look like, but I would like to draw some attention to the main points:<br /><ol><li>We put modifiers up front. Flags like :main, :load, :init, :named, and :slurpy go in front of the things they modify, and don't require colons.<br /></li><li>We declare variables with easy declarations like ".pmc foo", and disallow the use of implicitly-defined register names</li><li>No macros. We can use a separate precompiler like M4 if we want text substitution capability.</li><li>No heredocs. No POD. Actually, if we could find a good syntax for multi-line string literals, I wouldn't be against it, but the syntax used by heredocs in PIR is not particularly friendly.</li><li>Lexically nested subs are defined inside the :outer sub.</li><li>Subs have proper parameter lists with parenthesis. Also, I'm liking the idea of keeping the multisig near the parameter list, which is why I used the <> to include the multisig for the "bar" function above.</li><li>PMC literals can be defined in one of two ways. The first is for types that can be populated entirely through int-keyed or str-keyed access. I'm also thinking about ways to allow setattribute access too, though I need to find a good syntax for that. The second uses an initialization routine (similar to ":load :init" in PIR) that gets executed immediately after parsing and stores the result in the constant table with the given name.</li><li>Labels can take parameter lists.<br /></li></ol>I'm also considering adding if, unless, and while control constructs. for and foreach loops are too complicated. do/while style loops might be worthwhile as well. try/catch are too complicated and won't be used.<br /><br />