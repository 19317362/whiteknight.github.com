---
layout: bloggerpost
title: Misusing VTABLEs
---

I recently got into a discussion with Patrick Michaud about the behaviors of some VTABLE functions. Specifically, the issue was about ResizableStringArray's get_number function. It hadn't previously been implemented, and Austin suggested that it should return the value of get_integer, cast to a floating point value. The expressed reason for this desire is the current behavior of NQP, where all mathematics operations are done in floating point by default. What NQP does or does not do is not really my concern, it's a fine language project and does what it needs to do for a large number of compiler developers. Plus, it's not like NQP <span style="font-style: italic;">wants</span> to always using floating point for it's operations anyway; Parrot doesn't really provide any other option because we can't determine whether a given PMC intends to be used as an integer or a float in external mathematics operations.<br /><br />I won't really discuss NQP any further here. Like I said, what it does is perfectly fine, and Patrick is doing his best to work around problems at the Parrot-level.<br /><br />The real issue that I want to talk about is how VTABLEs are supposed to be used as a common interoperation interface between PMC types, but in practice it turns out to be used as an inconsistent mess. Let's learn through example:<br /><br />First, from the ticket I mention above, here's a quick example of how people try to treat arrays like integers:<br /><br />$P0 = new ['ResizableStringArray']<br />$P0 = 10<br />$I0 = $P0<br /><br />This sequence does two operations. First, it sets the array to the integer 10, which has the effect of expanding the array to have a capacity of 10. Uninitialized items are (or should be) initialized to a reasonable value like PMCNULL. Second, we treat the array as an l-value in an assignment to an integer, which has the effect of retrieving the number of elements in the array. While I would argue that this doesn't make a whole bunch of sense, it is used pretty consistently in the core repo. It's worth noting at this point that there exists a VTABLE_elements function whose explicit purpose is to provide a tally of the number of items in the array. In all array types in the Parrot repository, VTABLE_get_integer returns exactly the same result as VTABLE_get_elements.<br /><br />The issue that Austin raised was that in NQP he wanted to be able to do an operation similar to this:<br /><br />my $array = ResizableStringArray.new();<br />my $value = $array + 5;<br /><br />So he wasn't just using the treat-it-as-a-number value to retrieve the length of the array, he was actually using it directly as an operand in a mathematical calculation. If you don't have a solid background in Perl5, this has to feel a little bit wrong. In fact, for most other languages in this world, both static and dynamic, code similar to the above would cause an error.<br /><br />It's a bit of a cognitive stretch to think that when used in a mathematical expression that an array type would, by default, be it's length as an integer. I mean, an array <span style="font-style: italic;">is not</span> a number and it doesn't make a whole hell of a lot of sense to treat it like one. Sure, this:<br /><br />$I0 = $P0<br /><br />... is a little bit easier and faster to write than this:<br /><br />$I0 = elements $P0<br /><br />... though I would argue that it's a little bit less readable. Plus, I'm still of the mind that people shouldn't really be writing PIR directly at all (and then typing effort becomes a moot point).<br /><br />If it's a bit of a stretch to think that an array type returns it's element count when it's treated as a scalar integer, then it's much more of a stretch to think that the array should return it's element count when also treated as a scalar floating-point number.<br /><br />Let me go a step further: It's absurd to think that an aggregate PMC in Parrot (which, we all know, supports more than just Perl) should return it's count when treated as a scalar integer or floating point number. It's even more absurd when you consider that we explicitly provide a VTABLE_elements interface that's designed to give that information in a semantic-independant way. It's absolutely absurd that Parrot's core types are consistent in this behavior and therefore set a precedent that other array PMCs from other languages and other projects are going to be blindly expected to follow.<br /><br />If you want a count of an aggregates elements, use the "elements" opcode and the VTABLE_elements function. This is why they exist, and this is what they are supposed to provide.<br /><br />One thing that I've tried to do in my projects Parrot-Linear-Algebra and Parrot-Data-Structures is to explicitly avoid using these kinds of conventional shorthands in the data types I define there. Neither the various matrix types, stack types, or queue types that I've written, nor that other members of those projects have written, provide a get_integer VTABLE that returns the number of elements in the structure. We don't do it because it really doesn't make any sense for most of these types. Arrays, matrices, stacks and queues are not scalar types, and trying to boil them down to a single integer value without qualification is going to have to rely on some arbitrary default value that is right for some people and wrong for others.<br /><br />Here's a great example why: Parrot-Data-Structures provides fixed-length queue types that use pre-allocated storage. Storage is pre-allocated using the "$P0 = $I0" form, similar to how array lengths are pre-allocated in the fixed-size array types in the Parrot repository. The reason why we do this is because VTABLE_set_integer_native is the only available VTABLE for this purpose. Parrot doesn't provide a VTABLE_resize_int, or VTABLE_grow_int function that we could use. When I retrieve an integer value from a fixed-sized queue type, should I return the element count (which would be consistent with Parrot's native array types), or the amount of allocated storage (which would be consistent with the allocation syntax. If I do this:<br /><br />$P0 = new ['FixedPMCQueue']<br />$P0 = 5<br />$I0 = $P0<br />$P1 = new ['FixedPMCArray']<br />$P1 = 4<br />$I1 = $P1<br /><br />Do we want the value 5 in $I0, which would make it nicely symmetric with the "P0 = 5" line above, or do we want the count of elements, which would make it symmetric with the "$I1 = $P1" line in terms of semantics?<br /><br />Let's look at an even more rediculous example:<br /><br />$P0 = new ['PMCMatrix2D']<br />$P0 = 6<br />$I0 = $P0<br /><br />In this case, what does it even mean to say "$P0 = 5"? Does that set the size of the matrix? And if so, do we intend the matrix to have dimesions 1x6, 6x1, 2x3, or 3x2? Now pretend for a second that the second line of this example wasn't so lousy, what should the third line contain? Returning the length of the matrix here would make it roughly similar to the behavior of a ResizablePMCArray when the matrix is a row matrix. Returning the height is probably not the correct idea, and neither is returning the raw number of elements. Knowing the total number of elements in a matrix really isn't important as often as knowing the number of elements in an array. In order to understand a matrix and in order to be able to iterate over it's elements, we need to know all the dimensions of the matrix. In the 2-dimensional case, we really need to know width and height.<br /><br />The Parrot repository provides eight types that are explicitly listed as being array types, and a handful of others that could be repurposed through evil hackery to act like arrays if necessary. This provides quite a lot of precident among designers of other array types, and also creates places inside the VM where certain interfaces are expected to be provided by types calling themselves "array".<br /><br />There has been some talk of slimming this selection down to a single array type provided in the base repo, and I personally welcome that change. I really don't think Parrot should be providing by default a huge number of specilized types, especially if those types are not used directly inside the VM.<br /><br />My general option is, and always has been this: blind defaults are bad. Parrot shouldn't be presuming to provide your needed behavior for you, because Parrot cannot know in advance all the behaviors required from all the possible HLLs that might be implemented on it. In many cases, conflicting needs would prevent Parrot from satisfying the needs of all HLLs, producing a larger barrier to entry in cases where the defaults provided by Parrot conflict with the defaults provided by the HLL. Parrot should be providing a language-agnostic runtime that helps languages and doesn't get in the way.<br />