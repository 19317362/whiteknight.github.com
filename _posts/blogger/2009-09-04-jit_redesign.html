---
layout: bloggerpost
title: JIT Redesign
publish: true
categories: [JIT, Parrot]
---

The time has come. Parrot's JIT system is now in my crosshairs and phasers are set to kill.<br /><br />bacek has spent a lot of his time in the past two weeks working on the <a href="/2009/09/03/context_pmc_follow_up.html.html">Context PMC stuff</a>. The last thing he was blocking on was a failure in the JIT system that only appeared when "make testj" was run. I, of course, couldn't even observe this failure because Parrot doesn't have JIT support on x86_64. The root problem for him was that the JIT system has a lot of hardcoded knowledge about the shape of some of Parrot's core data structures, and any changes to those structures breaks what JIT thinks it knows. In response to this problem, and some frustrations I have been building up over the past few months, <a href="http://lists.parrot.org/pipermail/parrot-dev/2009-August/002754.html">I sent a mail to the list</a> suggesting we deprecate the current JIT system and schedule it for removal in 2.0. Response there was mostly positive, but the ball really got moving when <a href="http://irclog.perlgeek.de/parrotsketch/2009-09-01#i_1454345">I mentioned the issue</a> in this week's #parrotsketch meeting.<br /><br />Why do I want to deprecate JIT? Isn't JIT the new hotness for virtual machines and interpreters? Isn't it the savior of performance for dynamic languages? The short answer is that I want to deprecate our current JIT implementation and replace it with something even better.<br /><br />What JIT does is this: It takes information about the instructions to execute from the parser. This is going to be the compiler's Low-level Intermediate Representation (LIR). Parrot's LIR is the compiled bytecode that we are supposed to execute. JIT takes this information and converts it to machine code on the fly, so that it can be executed directly by the processor without need to dispatch to op routines. In theory what this can do is significantly reduce the <a href="/2009/06/29/understanding_opcode_dispatch.html.html">overhead of opcode dispatch</a>, by making control flow more "natural" to the machine, which in turn helps with branch prediction and caching. If you combine this with the ability of some JIT engines to optimize the output machine code agressively, you can end up with some major performance savings with a good JIT. I'll discuss the workings of JIT<a href="/categories/ParrotTheory.html"> in more detail</a> later this weekend.<br /><br />In short, Parrot wants JIT. Parrot <span style="font-style: italic;">needs</span> JIT. We simply aren't going to be a viable alternative to other VMs without it in the long term. Especially not when you start looking at some of the <a href="http://ejohn.org/blog/tracemonkey/">amazing performance improvements</a> VMs have been making recently directly because of their JITs.<br /><br />Parrot's current JIT just doesn't fit the bill though. It suffers from a number of terrible problems, which I enumerated to the list also:<br /><ol><li>It doesn't really provide much performance improvement for most programs. It also doesn't have much opportunity to perform any optimizations at the machine-code level.<br /></li><li>It is too closely tied to Parrot's core, breaking all sorts of encapsulation barriers. As I said earlier, the JIT system needs to mirror certain algorithms and data structures used in Parrot core, which means a change made in the one needs to be faithfully preserved in the other. When we can't do that because none of our current developers know the system well enough we end up with a huge decrease in development momentum. Of course an argument could be made here that more people need to learn the JIT system.<br /></li><li>Parrot's JIT system is very platform specific. There simply is no implementation on most systems (only x86 and PPC have it), and there is no easy way to share code between platforms to give new platforms a head start. If I want to write a JIT for a different system (such as amd64 for example), I basically need to start completely from scratch.<br /></li><li>It is an absolute mess, and a maintainability nightmare. Nobody really knows what all it does or how it all works. It's also not documented well enough to bring any new developers up to speed on it. Top this all off with the overly complicated way that it is written. We simply can't make any improvements on the code, not without a herculean effort that honestly isn't worth the time.</li><li>It is nowhere near some of the other existing JIT engines in terms of usability, quality of generated code or capabilities. libJIT, nanoJIT and LLVM have entire dedicated teams working on them, we aren't ever going to match what they have without a similar expenditure of time and effort.<br /></li></ol>So I made the request that we deprecate the system. But not just that, I suggested that we start serious planning for a replacement. And I mean serious. I've been beating the pavement for the last two days, tracking down developers and asking questions. Some of the fruits of my labor have already been <a href="https://trac.parrot.org/parrot/wiki/JITRewrite">added to the wiki</a>. Here are some ideas that I have about how our future JIT system could work (I'll explain this all in more detail later). Notice that this is not an order of tasks, just a logical outline of the system I am envisioning:<br /><ol><li>We rewrite Parrot's PASM ops in terms of a new LIR. This could be <a href="/2009/06/26/l1_lets_review_faq.html.html">Lorito (Previously L1) </a>if we want it to be backend-neutral, or it could be something that's specific to the particular JIT engine we use (like LLVM ops, for example).<br /></li><li>We need to be able to convert the <a href="/2009/06/11/l1_the_language_of_parrot_internals.html.html">LIR to C for direct execution, and to a JIT definition for indirect execution</a>. There are a number of ways we could do this, depending on the skills and availability of our development team.</li><li>The configure system will determine which JIT backends are available (if any), and generate the necessary code to support them during the build.</li><li>We only need a minimal API that the Core of Parrot will interact with: JIT the incoming PBC, call into JIT'd code, output an executable and maybe a select few other operations. Much of the code can be generated at build time.<br /></li></ol>This kind of system gives us pluggability in the sense that we can support multiple JIT engines, even though we can only plug them during the build. It also means we don't have to define a huge comprehensive API to satisfy all JIT engines, we only need a minimal API and can generate the rest of the code specifically for individual JITs.<br /><br />Obviously this is all very preliminary, and we will refine the design as we move forward and gather more information about all our options. I'm sure I'll be posting updates here as new things start happening.