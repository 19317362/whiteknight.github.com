---
layout: bloggerpost
title: CS Education
publish: true
categories: [Engineering, Software, Education]
---

Let me preface this post by saying that I don't have a CS (Computer Science) degree. I majored Electrical Engineering for my undergrad and Computer Engineering for my masters degree.<br /><br />Yesterday I read a very interesting series of blog posts about the state of CS education. First up was "<a href="http://www.joelonsoftware.com/items/2009/10/26.html">Joel of Software</a>" with a post about how lousy CS education is. Next up was "<a href="http://stochasticgeometry.wordpress.com/2009/10/27/joel-spolsky-snake-oil-salesman/">Stochastic Geometry</a>" with a post rebuking Joel. Finally, <a href="http://use.perl.org/%7EOvid/journal/39809?from=rss">Ovid had a nice post</a> about his reactions to them.<br /><br />I can tell that the state of computer engineering education is lousy, and I have heard enough from professors and students to know that the state of computer science education is lousy too. It's hard to really put a finger on what exactly is wrong with the system, however. First, let's distill the good points of what Joel has to say:<br /><ol><li>Students aren't doing enough team work</li><li>Students aren't good at time management</li><li>Students don't write large programs</li><li>Students don't have to spend much time debugging, stabilizing, securing, or maintaining software in the long term.</li></ol>These points are all true, and go largely unaddressed by Stochastic Geometry. However, in the flip side, let's look at what the response had to say:<br /><ol><li>Any particular tool is unimportant compared to learning a class of tools</li><li>Learning the theoretical fundamentals is important, because it allows the student to learn specifics more easily.<br /></li><li>Teaching one particular methodology is harmful, because there are no standards and no proof that any one methodology is beneficial or even widely used.</li></ol>Since joining my job, I've had the privilege to participate in a few interviews of new applicants. Most of the jobs we've been looking to fill are entry-level, so many of our applicants were  fresh out of school. We had one candidate in particular with a dual major in CS and CE from a school that, I thought, had a decent program. He had a nice resume and a decent GPA, so we were hopeful.<br /><br />We started with some low-ball sanity questions.  First up: "How many bits are in a word?" There are a few good ways to answer this one, and while it may seem esoteric it is profoundly important when talking about embedded systems. Savvy readers will realize that this is sort of a trick question. The term "word" in computers has a number of different meanings depending on context. An acceptable, though naive, answer would have been "16". A better answer would have been something like "it depends on the system. 32-bit computers have a 32-bit word, 64-bit computers have a 64-bit word, etc". A great answer would have included the previous one, and included "though in some programming spheres, 'word' is defined to always mean 16-bit and double-word (32) and quad-word (64) are defined to mean other things, regardless of the size of the machine word". All of these would have been acceptable. His answer: "I don't know."<br /><br />We were stunned, and tried to give him some help, but he simply didn't know the answer. So we moved to a less-difficult question, to try and coax some information that was buried a little too deep: "How many bits in a byte?". He didn't know that either. Thanks for coming in today, but the interview is now over.<br /><br />Without fail. Without any exceptions, the best potential applicants I've seen for my place of work, and the best software developers that I've known from other contexts, have significant programming experience outside of school.  Sometimes this comes some independent learning and small personal projects. Sometimes this takes the form of Open Source Software contributions. I make no secret of the fact that my participation in Parrot has had one of the biggest beneficial effects on my skill as a coder. I am far more influenced by my work in Parrot then I was by anything I did in school. I'm more influenced by it then I am from my full-time job. It really is an immeasurably wonderful environment to work in, and gives that kind of practical immersion that a university degree really can't provide<br /><br />One applicant we talked to listed PHP on his resume. I asked, "Where did you learn PHP, in school?". To which he replied, "No, I taught it to myself."<br /><br />"Why?"<br /><br />"Just because I was interested in it and wanted to know how it works."<br /><br />That applicant got the job, and has proven to be very successful at it. It didn't hurt that he knew how many bits were in a byte.<br /><br />There was a time when people went into computer programming for the money. Back in the heyday of Silicone Valley and the .Com Bubble, there was money to be made hand-over-fist for any programmer who was able to dip into it. Reality has set in now, and this isn't the field to get into if you're only looking for some easy cash. In fact, if you don't stand out from the crowd in some way, you're more likely to be unemployed. I graduated with a lot of other EE and CS majors who settled for jobs in sales or marketing when they couldn't find a tech-related one. I knew one Masters degree recipient who had to work at Target for a while because there were no jobs for him whatsoever.<br /><br />Every recent college graduate will tell you that almost every single job listing they find requires at least one year of experience. The naive will say "How am I supposed to get the experience in the first place, if I can't get a job that requires prior experience?" In some cases internships can go a long way towards greasing those skids. However, the bigger question is this: If you're fresh out of school and have all the fun facts and theory fresh in your mind, why do you need experience? You need it because school doesn't really prepare you for a job at all: it prepares you to prepare yourself to get a job.<br /><br />I don't want to scare anybody away, but I do need to make this point: If you aren't good at it, you won't easily find a good job programming or web developing. Coming out of college you  <span style="font-style: italic;">will not be any good at it</span> if you don't have any other experience. This is an undisputable fact, a college education simply does not and cannot prepare you for a real job in the real world of computer programming. You're going to have to put in the extra effort yourself. You're going to have to fill in the gaps yourself. You're going to have to learn the important lessons yourself. College made you capable of learning, now the onus is on you to <span style="font-style: italic;">actually learn</span>. Going back for a masters degree is a good idea. Internships are good. Doing little contracts for small local businesses can be good too. Classes and training courses are good, and they happen in all sorts of places at all times of the year. Participating in an open-source software project is, in my estimation, the best.<br /><br />The last option is my favorite, but so many people shy away from it: "I don't want to spend my free time writing code". To this I have two replies. First, if you don't want to write code, why are you pursuing a career in it? Second, what are you going to say when your future boss hands you a blackberry and tells you that you are on-call 24/7 and are expected to jump anytime the system goes down? Or when your boss tells you that the entire team is expected to put in 10-20 additional hours of overtime per week, every week, until the next release?<br /><br />So in conclusion, my point is this: a college education, especially in the fields of CS or CE, will teach you the basics and the fundamentals, and put you into a position to learn new things and adapt to new work environments. It will not directly prepare you for a good job as a programmer. What a college education does (and this is <span style="font-style: italic;">extremely important</span>, even if it doesn't sound it) is to prepare you to learn the new things you will need to be a programmer. You have to do the learning yourself. Joel is right to point out that students are coming out of college woefully unprepared for work. He is also right to point out the problem belongs to the students themselves. Stochastic Geometry is right to point out that colleges are doing what they should, and that teaching the fundamentals is very important. The missing link is that the students need to go through the last few preparation steps themselves. Students need to get the extra real-world experiences themselves to complement the fundamentals they've learned in college. Participating in a good open source project will teach you the necessary lessons, will look great on a resume, and will act as that final bit of preparation to get you into the good jobs you want.
                <div class='old-blogger-comments'>
                    <h2 class='old-comment-header'>Comments</h3>
                
<div class='blogger-comment-div'>
    <a name='1238274762977031067'></a>
    <p class='blogger-comment-body'>
        Just to complicate things further, I did actually point out that things like team projects and such *are* done in CS and CEng courses; and have been done there for decades. Just not from day one, because on day one, most CS and CEng students *don't know how to program at all*. They're straight out of school, they're 17, 18 years old, and if they've got any computer experience past using a playstation, they're the exception even in the top 10% of students the colleges take in. Four years later, they've written compilers, understand SQL, have been coding for four years, have hand-wire-wrapped a basic computer from a bunch of chips, some wire and a lot of swearing, and have worked on one six-month project as a final year dissertation (and it's not uncommon for those to be advanced enough to be written up as conference papers and published) and if they're good, have taken part in a few extracirricular competitions as well. That's not bad for a bunch of kids who wouldn't know their MSBs from their LSBs when they started four years earlier.<br /><br />There's also the point that while some schools are good for CS/CEng study, with decent degree programmes and good teaching practices ... you will also find not-so-good schools. As in every field of academic study. And it's not fair to criticise the best because of the failings of the worst. <br /><br />And to be even more annoying, there's the point that all the points Joel made in his first 12 paragraphs, he cuts off at the knees in his last two paragraphs, saying in effect that all industrial programmers are as hopeless as he thinks all students are, and if it wasn't for managers imposing time management on them, they'd never get anything done. <br /><br />Me, I tend to remember Ariane 5 flight 501, Challanger's SRBs and the Genesis probe's "landing" when I hear managers promoting their job like that...
    </p>
    <div class='blogger-comment-author-div'>
        <span class='blogger-author-sig'><a class='blogger-author-uri' href='http://stochasticgeometry.wordpress.com/'>stochasticgeometry</a>
</span>
        <span class='blogger-comment-datestamp'>
            <a class='blogger-comment-link' href='{{ post.url }}#1238274762977031067'>
                10/31/2009 7:52:29 PM
            </a>
        </span>
    </div>
</div>
</div>
