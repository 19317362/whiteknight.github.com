---
layout: bloggerpost
title: PDD23 Exceptions Critique
publish: true
categories: [ParrotDesign, Parrot, Exceptions]
---

Following <a href="/2010/02/23/parrots_exceptions_system.html.html">my post a few days ago</a>, I would like to take a more in-depth look at <a href="http://trac.parrot.org/parrot/browser/trunk/docs/pdds/pdd23_exceptions.pod">PDD23</a>, which lays the specification for the exceptions subsystem. I hadn't intended to go through line-by-line, but in a lot of places I have to.<br /><br />[<span style="font-weight: bold;">Update</span>: I wrote this post at the same time as I wrote the last one on the topic, but I delayed in posting this one until now. In the interim time, Austin <a href="http://trac.parrot.org/parrot/wiki/ExceptionRefactor">created a page on the wiki</a> to plan out a major refactor of the system and Tene <a href="http://trac.parrot.org/parrot/log/branches/exceptions_refactor?rev=44392">started a branch</a> to do some work. I'll post updates on both those things as they happen.]<br /><br /><blockquote>exceptions are indications by running code that something unusual -- an "exception" to the normal processing -- has occurred.  When code detects an exceptional condition, it throws an exception object.  Before this occurs, code can register exception handlers, which are functions (or closures) which may (but are not obligated to) handle the exception.  Some exceptions permit continued execution immediately after the throw; some don't.<br /><br />Exceptions transfer control to a piece of code outside the normal flow of control.  They are mainly used for error reporting or cleanup tasks.</blockquote><br />This is, essentially, the preamble to the rest of the document and already shows some disconnect with reality. High level languages are already using exceptions to handle normal control flow in some cases. In this case they are less "exception" and more "<a href="http://en.wikipedia.org/wiki/Expection_handling">expection</a>". I could go on and talk about how bad an idea it is to use exceptions for normal control flow for a variety of reasons, but I won't. I know that Parrot's control flow model still isn't mature enough to tackle all the cases that HLLs have been digging up, so exceptions are the only available mechanism to implement some structures. Also, that I am aware of, no exception prevents resuming after the point of the throw. I believe that determination is left up to the handler.<br /><br /><blockquote>When an exception is thrown, Parrot walks up the stack of active exception handlers, invoking each one in turn, but still in the dynamic context of the exception (i.e. the call stack is not unwound first).</blockquote><br />I need to carefully read through some of the code again, but I'm pretty certain that this is patently false. ExceptionHandlers are implemented as Continuations which <span style="font-style: italic;">do</span> rewind the call stack and are executed in the dynamic context of the function that contains the handler. Again, I need to look at all the code and the semantics in greater detail, but at the very least this is highly suspect.<br /><br /><blockquote>Exception handlers can resume execution after handling the exception by<br />invoking the continuation stored in the 'resume' slot of the exception object. That continuation must be invoked with no parameters; in other words, throw never returns a value.</blockquote><br />Not a problem here so much as a little nit. Why <span style="font-style: italic;">can't</span> exception resumes return values? If you think about common exception uses in some popular programming languages this is never used. But when you consider that exceptions in Parrot are currently used, as I mention above, to implement complex control flow, you start to see that there is maybe some utility to it. Slightly more to the point, what if the resume object wasn't just a continuation pointing to the opcode after the throw instruction, but was instead a Sub object representing a lexically-scoped finally&#123;&#125; block that needed to be invoked? I can come up with a few ideas of places where the functionality to pass parameters to the resume continuation might be nice to have. It's interesting to consider that maybe we resume to a multi-sub, which dispatches to a post-handler routine based on signature? I have several ideas like this, and while they are all a little bit off the radar of current programming languages they are by no means unthinkable or undesirable in the long run. If it's possible to provide this, and Parrot's internal mechanics should certainly make it so, I don't see why we would artificially limit it.<br /><br /><blockquote>The die opcode throws an exception of type exception;death and severity<br />except_error with a payload of message.  The exception payload is a string PMC containing message.</blockquote><br />I have been accused of being anti-Perl, and I maintain that I am not. Maybe I'll devote another blog post to the topic later. But I don't think Parrot needs a "die" op that does what it does here. I can understand and appreciate that Perl is very motivated by linguistic factors, and that Parrot has been traditionally very influenced by Perl. But Parrot's opcodes represent an assembly language, and using these kinds of linguistic features seems a little bit out of place. Why have "die", when we have "exit"?<br /><br />The routines to search the op library are not linear. I think it uses a <a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>, but I haven't studied the implementation enough to be able to say so definitively. What I do know is that the time it takes to search the oplist for a valid op name is proportional in some measure to the number of op "short" names. I think it's O(log n). As an example, die_s, die_p, and die_i_i all have the short name "die". IMCC, during lexical analysis, looks to determine whether an opcode exists in the library using it's short name. Later in the process, IMCC hunts down the exact long name of the op, which again uses the same algorithm (skip list?) but looks at long names instead of short names. I'll spare more details on this point, but the lesson is clear: Having fewer ops is better for IMCC's code generation performance. Having fewer short names (even if the number of ops remains the same) improves parsing performance in IMCC. For a PIR-based benchmark, we would see some improvement (though admittedly it would be very small) if we did nothing besides rename all "die" opcodes to "exit" instead.<br /><br />When I see the word "die", It seems to me like it should do what it says: Kill the program. Do not pass go. Do not collect 200 dollars. <span style="font-style: italic;">Die</span>. I can't imagine having any other preconception about it. Why would the "die" opcode not make the program...die? At least, why not without an explicitly-defined mechanism to prevent it, such as how Perl5 uses eval()? So you can imagine my surprise that die seems to throw just another exception that can be caught. You can imagine how perplexed I tried calling<br /><pre><br />die 'Program is closing'<br /></pre><br />or<br /><pre><br />exit 0<br /></pre><br />didn't exit my program! Instead, I had to use<br /><pre><br />die 5, 0<br /></pre><br />to tell the system that yes, I actually wanted the program to shut down. Of course, now I can't supply a helpful message about <span style="font-style: italic;">why</span> we need to die. It's also surprising to me that, for some reason, the exit opcode seems to have the same general behavior. It doesn't actually exit if you have a handler active, and doesn't have an overload that let's you manually specify a severity that forces an exit. So that seems pointless to me. Again, what else could the word "exit" mean besides "get out of my damn program"?<br /><br /><blockquote>All exceptions will have at least message, severity, resume, and payload attributes.</blockquote><br />There are three forms of the die opcode: die_s, die_p, and die_i_i. The first two basically throw a normal, catchable exception with the given argument treated as the string message to display to the user. The third form throws a normal, catchable exception with a user-definable severity and error code. The exit opcode has form exit_i, which throws a normal, catchable exception with only the given error code. The throw opcode has flavors throw_p, and throw_p_p, which let you throw a given pre-constructed exception, optionally with a given resume continuation. This all seems like a hugely redundant waste of opcodes which all essentially do the same thing but each of which only lets you specify a subset of the parameters that every exception object is supposed to provide. None of the opcodes allow you to specify a payload, even though the spec suggests (as I will discuss below) the payload should be used for type filtering by HLLs, and the current implementation prevents proper type subclassing!<br /><br />"die" lets you specify a message <span style="font-style: italic;">or</span> a severity and error code, but doesn't actually make the program die. "exit" lets you specify an error code only, and doesn't necessarily make the program exit. "throw" lets you specify a pre-built exception and optionally a custom resume continuation only. Considering that every exception <span style="font-style: italic;">must have a message, severity, resume, and payload</span>, this assortment of opcodes really doesn't make any sense at all.<br /><br />I won't harp on opcodes any further in this post, but I think I've made my point: The ops we do have are a stupid mish-mash of the kinds of ops we need to work with exceptions. If every Exception <span style="font-weight: bold;">must</span> have resume, severity, type, and payload, why do our ops not support that? Why do we have die, when we have throw, rethrow, and exit? I <span style="font-style: italic;">highly</span> suggest we slim down these opcodes. I think an exit_i opcode is fine, if it forces an exit in lieu of a specifically-defined exit-handler. That is, most handlers would not handle exit events by default, allowing the exit op to do what we expect. To catch and handle these types, which would be necessary in some places involving embedding or nesting, we could specifically define an exit-handler type that is capable of catching them.<br /><br />I think a throw_p opcode is all we really need to throw other types of exceptions. Maybe, if we were worried about writing out all the PIR for constructing elaborate Exception objects, we could have a throw_p_s_i_i, which would set all four required attributes at once, and throw it.<br /><br />Anyway, that's enough on this particular subtopic. But, in tangent, I would like to suggest again that we try to find a good way to specify aggregate literals in PIR code. In this way we could specify exception constants (or proto-exception initializer objects) to reduce the runtime cost of constructing exceptions where things like the severity, type, and message are the same. The ability to specify ExceptionHandler constants in the code likewise would create a huge performance savings, especially when you consider that in a normally-operating program more ExceptionHandlers are created and registered than Exceptions.<br /><br /><blockquote>count_eh Return the quantity of currently active exception handlers.</blockquote><br />I'm not certain that we need an opcode for this, especially since I think it's used pretty infrequently. A method call on the current context object could provide the same info. A series of methods would allow fine-grained manipulation of the handler stack, which would be even better.<br /><br /><blockquote>If no handler is found, and the exception is non-fatal (such as a warning), and there is a continuation in the exception record (because the throwing opcode was throw), invoke the continuation (resume execution). Whether to resume or die when an exception isn't handled is determined by the severity of the exception.</blockquote><br /><br />I'm not sure if the implementation follows the letter of the spec in regards to the "exception record". As far as I am aware, an unhandled exception doesn't automatically cause the program to resume normal control flow no matter what type it is. I need to check on this, but I have never witnessed this behavior. If it does exist, I apologize for not knowing about it, of course.<br /><pre><br />typedef enum &#123;<br />  EXCEPT_normal  = 0,<br />  EXCEPT_warning = 1,<br />  EXCEPT_error   = 2,<br />  EXCEPT_severe  = 3,<br />  EXCEPT_fatal   = 4,<br />  EXCEPT_doomed  = 5,<br />  EXCEPT_exit    = 6<br />&#125; exception_severity;<br /></pre><br />As Austin mentioned, there are way too many of these. Also, as I've found out experimentally, only EXCEPT_doomed actually causes Parrot to exit despite other severities having harmful-sounding names like "fatal", and "exit". In my mind we need only four severities, at most: Trivial, Normal, Fatal and Control. Anything else is superfluous, not just in theory but also in the code as it currently exists. Trivial exceptions can automatically resume if unhandled. Normal exceptions are ones that represent an error. They can be handled by any default handler, but cause a program exit when unhandled. Fatal exceptions mark an error that is typically unrecoverable <span style="font-style: italic;">unless</span> a special exit handler has been specifically configured to catch such events. Control exceptions bypass the error-reporting system and are used to implement non-error control flow. I'm hard-pressed to come up with any other designations we would ever need for this mechanism.<br /><pre><br />typedef enum &#123;<br />  EXCEPTION_BAD_BUFFER_SIZE,<br />  EXCEPTION_MISSING_ENCODING_NAME,<br />  EXCEPTION_INVALID_STRING_REPRESENTATION,<br />  EXCEPTION_ICU_ERROR,<br />  EXCEPTION_UNIMPLEMENTED,<br />  EXCEPTION_NULL_REG_ACCESS,<br />  EXCEPTION_NO_REG_FRAMES,<br />  EXCEPTION_SUBSTR_OUT_OF_STRING,<br />  EXCEPTION_ORD_OUT_OF_STRING,<br />  ...<br />&#125; exception_type_enum;<br /></pre><br />There are a huge number of exception types, and they really seem superfluous when you consider that every exception <span style="font-style: italic;">must</span> contain a message field with a human-readable message that describes it and a payload field that can contain any arbitrary object with additional data. I know that the intention with this huge list is to implement exception types without using subclasses. The reason for this is that subclasses can be largely expensive because each subclass needs to have it's own VTABLE and other information which can become prohibitive if we want to have more than a few types. I've recently put forward an idea for allowing<a href="/2010/02/23/cheap_subclasses.html.html"> extremely inexpensive subclasses</a> which was inspired by exactly this problem. My idea was not without it's caveats, of course, but it's not the only possible route to take to make the subclassing operation less expensive. That said...<br /><br /><blockquote>The payload more specifically identifies the detailed cause/nature of<br />the exception.  Each exception class will have its own specific payload type(s).  See the table of standard exception classes for examples.</blockquote><br /><br />So every Exception has a payload, which can be a user-defined object type with information about the exception type, <span style="font-style: italic;">and</span> it needs to have one of these dozens of enum values that indicates it's type? This is all highly redundant, and there are at least two paths we could follow to make this system sane:<br /><ol><li>Only have one type of Exception PMC with no subclasses. Get rid of the type enums. The Exception "type" can be determined from the user-specified payload, if any. Add opcodes or methods that better facilitate throwing an exception with a custom payload. We're likely going to need to define several "Payload" PMC types to handle those exceptions thrown by core. This would require implementing cheap subclasses, but has the benefit that built-in types can be overridden by HLL types if needed.</li><li>Have many subclasses of Exception. Get rid of type enums. We only need a throw_p opcode and can construct "new ['ICUError']" objects or whatever we need. This is going to require implementation of cheap subclasses, and will allow HLL type overrides if needed.</li></ol>Either way, a major improvement over what we have now.<br /><blockquote>Exceptions have been incorporated into built-in opcodes in a limited way.  For the most part, they're used when the return value is either impractical to<br />check (perhaps because we don't want to add that many error checks in line), or where the output type is unable to represent an error state (e.g. the output I register of the ord opcode).</blockquote><br /><br />Color me stupid, but isn't consistency of interface a good thing? How do we know, without having to memorize the behavior of all 1302 ops, which throw exceptions to signal errors and which do not?<br /><br /><blockquote>Other opcodes respond to an errorson setting to decide whether to throw an exception or return an error value.</blockquote><br /><br />I think this should be the default behavior. All ops should throw exceptions on error if "ops throw exceptions" is turned on. Otherwise, no ops do. This setting is cheap enough to toggle.<br /><br /><blockquote>&#123;&#123; TODO: "errorson" as specified is dynamically rather than lexically<br />scoped; is this good? Probably not good. Let's revisit it when we get the basic exceptions functionality implemented. &#125;&#125;</blockquote> <br /><br />Good point! Maybe an opcode for this isn't a great idea. Methods on the ParrotInterpreter object (to set global settings) and methods on the CallContext PMC (to set local settings) would be a good alternative. When is the basic implementation expected?<br /><br /><blockquote>&#123;&#123; NOTE: There are a couple of different factors here.  One is the ability to globally define the severity of certain exceptions or categories of exceptions without needing to define a handler for each one. (e.g. Perl 6 may have pragmas to set how severe type-checking errors are. A simple "incompatible type" error may be fatal under one pragma, a resumable warning under another pragma, and completely silent under a third pragma.) Another is the ability to "defang" opcodes so they return error codes instead of throwing exceptions. We might provide a very simple interface to catch an exception and capture its payload without the full complexity of manually defining exception handlers (though it would still be implemented as an exception handler internally)</blockquote><br /><br />Another warning in the same vein as the previous note. The point here is that we may want to say that some opcodes throw exceptions, but that we may want those exceptions to have different effects under different "pragmas". This kind of system can be hugely expensive if every error-capable opcode needs to check not only whether to return an error code or throw an exception, but also what the severity of that exception is depending on a series of pragmata that, most likely, would need to be lexically-scoped anyway. Way too complicated. Far better is to enable cheap subclasses of Exception, and have the HLL hot-swap type-maps at runtime with different behaviors such as different severities. Or better yet, forget hot-swapping and instead introspect on the Exception subclasses' Class object to change the default severity values and behaviors. That way when the new Exception object is created, the initialization routine sets a different default severity, the op throws it no matter what, and the exceptions system handles things like it is supposed to do.<br /><br />So that's my in-depth critique of the Exceptions PDD. I may make it a regular feature to go through other PDDs as well, and I'm sure I'll post other ideas, proposals, and insights for this system in the future as well.
                <div class='old-blogger-comments'>
                    <h2 class='old-comment-header'>Comments</h3>
                
<div class='blogger-comment-div'>
    <a name='7580278710367913112'></a>
    <p class='blogger-comment-body'>
        If IMCC needs to look into the op lib during lexical analysis, there is probably a design flaw. The opcode should probably only be checked during the parse / semantic check phase. If you want to tweak that much more performance out of IMCC you'd probably be better autogenerating the short op-list into imcc.l before calling lex so the token list is built directly into the scanner. As to your die vs. exit, I agree. This is where there is too much Perl influence in the VM. Things like 'die' semantics are better implemented in high level. Give the VM a simple opcode for termination, let all other things (printing messages, etc.) be implemented on top of the core op. I was arguing this in 2001/2002. If I had it my way, the core ops would be lean, and all the PMC grunge would have been implemented on top of those lean ops, not in the wacky .pmc/VTABLE mechanism that exists now. 99% of the Parrot lib would be written in a single, consistent HLL, and the JIT would be manageable. Right now, even as an original Parrot developer, I cannot wade in. Parrot requires a mix of Perl, PIR, C and custom build macros. PMCs are not Objects and Objects are not PMCs. There are still multiple cores for the fun of it. etc. etc. If Parrot is to ever really be done, seriously, someone needs to take a scalpel to about 50% of the "sacred" parts of the codebase and cut the amount of busy work and maintenance that has to be done, and remove some of the "multiple options" for accomplishing the same thing. Examples of projects that succeeded much faster than us are Mono. They built a canonical compiler (C#) and then proceeded in implementing the platform using the C# compiler. I was arguing that this would have been Cola at the time, and was my intent when I wrote PIR and the simple Cola compiler. But 8 years later, there is no JIT and Parrot is looking at using projects that started well after itself. I cringe when I look at all the hand-written .pir files in the distro. This was not the intent of PIR. Anyway, good luck. Don't take my comments th wrong way, hopefully they'll spark some debate. I'll check in in 2012. :) --mrjoltcola
    </p>
    <div class='blogger-comment-author-div'>
        <span class='blogger-author-sig'><a class='blogger-author-uri' href='http://www.blogger.com/profile/05409197922206203700'>Melvin Smith</a>
</span>
        <span class='blogger-comment-datestamp'>
            <a class='blogger-comment-link' href='{{ post.url }}#7580278710367913112'>
                3/15/2010 10:56:04 PM
            </a>
        </span>
    </div>
</div>
</div>
