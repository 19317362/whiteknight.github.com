---
layout: bloggerpost
title: Difference between PMCs and Objects
publish: true
categories: [PMC, Parrot, Objects]
---

There has been lots of talk and activity lately that has to deal with Parrot Objects.  My rant about exceptions in Parrot has incited Tene to begin a flurry of development on that system, and <a href="http://gitorious.org/kakapo/kakapo">Austin's Kakapo project</a> has been regularly pushing the boundaries of what kinds of operations are and should be possible (and finding lots of bugs along the way!). Other people have been bringing up the topic as well, and lots of people are asking lots of questions about the implementation. I'm going to use this post to explain a bit about how <a href="http://trac.parrot.org/parrot/browser/trunk/docs/pdds/pdd15_objects.pod">Objects</a> and <a href="http://trac.parrot.org/parrot/browser/trunk/docs/pdds/pdd17_pmc.pod">PMCs</a> work in Parrot, and maybe later I'll devote a post or two to ideas for fixing this system.<br /><br />PMCs are basically <a href="http://en.wikipedia.org/wiki/Object_%28computer_science%29">objects</a>, though extremely simple, flexible, and low-level. PMCs are interacted with, primarily, through the <a href="http://en.wikipedia.org/wiki/Virtual_function_table">VTABLE</a> interface. VTABLEs in Parrot are long lists of C function pointers that implement various behaviors. Calling the in-place addition VTABLE, add_i, is done like this in C:<br /><pre><br />VTABLE_add_i(interp, pmc, 5);<br /></pre><br />...Which translates to this:<br /><pre><br />pmc->vtable->add_i(interp, pmc, 5);<br /></pre><br />By pointing to a per-type VTABLE structure, PMCs with the same type can access a common list of function behaviors without overlapping or needing to do expensive switch/cases over a list of direct function calls. Likewise, determining the type of a PMC means finding the type of the VTABLE it points to:<br /><pre><br />pmc->vtable->base_type;  // type number<br />pmc->vtable->whoami;     // type name (Parrot STRING)<br />pmc->vtable->class;          // Class or PMCProxy PMC for the type<br /></pre><br />Also, if we have the type number, we can look up the particular VTABLE in an array:<br /><pre><br />VTABLE * tbl = interp->vtable[index];<br /></pre><br />In a sense, that's all there is to a PMC. All interactions with a PMC happen through this interface of about 185 function pointers. A PMC, by itself, doesn't have things that we would normally associate with "objects" in higher-level systems: <a href="http://en.wikipedia.org/wiki/Attribute_%28computing%29">Attributes</a> and <a href="http://en.wikipedia.org/wiki/Method_%28computer_science%29">Methods</a>. Sure, PMCs do have a way to associate a C structure, and therefore maintain a list of what we call "attributes", but those aren't directly accessible from PIR without adding some kind of lookup routine to find them and maybe wrap them into one of the Parrot register types (INTVAL, FLOATVAL, STRING, PMC). PMCs also appear to have methods, but this really isn't the case when you look at it closely.<br /><br />As I describe in a previous post, the long way to invoke a method on a PMC is like this:<br /><pre><br />$P0 = new ['Foo']<br />$P1 = find_method $P0, "bar"<br />callmethodcc $P0, $P1<br /></pre><br />The find_method opcode is a thin wrapper around the VTABLE_find_method interface function. If I translate this to an extremely condensed and wildly inaccurate pseudo-C listing, we get:<br /><pre><br />PMC * p0 = Parrot_pmc_new(interp, type_Foo);<br />PMC * p1 = VTABLE_find_method(interp, p0, "bar");<br />setup_method_call(interp, p0);<br />VTABLE_invoke(interp, p1);<br /></pre><br />This is obviously an extremely inaccurate listing, but should do well to illustrate my point. The method is actually a separate PMC type. It can be either a Sub (a .sub written in PIR) or an NCI (a wrapper type around a C function call). To make the call we set up the argument list (the invocant, $P0, is treated sort of like an argument but is kept distinct) and then invoke the method.<br /><br />Before they are invoked, methods are stored inside either a Class or PMCProxy PMC associated with that type. When we call VTABLE_find_method(interp, p0, "bar"), we go through this machination:<br /><pre><br />PMC * class = pmc->vtable->class;<br />PMC * methods = class->data->methods;<br />PMC * method = VTABLE_get_pmc_keyed_str(interp, methods, "bar");<br /></pre><br />What we think of as an "object" and a "<a href="http://en.wikipedia.org/wiki/Class_%28computer_science%29">class</a>" is actually a small collection of interoperating PMCs. The PMC itself contains a long list of VTABLEs and a small amount of data stored in a C structure, which cannot be directly accessed from PIR code. The PMCProxy PMC (like Class, which I will describe later, but designed to work with PMC types written in C) contains a hash of methods and a variety of other data. Methods themselves are their own PMCs, complete with their own type data. To really blow your mind consider that, as a PMC, you can call a method on a method, or even a method on a method on a method.<br /><br />In short, a PMC is sort of like the building block that is used to create objects and a type system, though the PMCs themselves are not what we normally think of as "objects". The only way to interact with a PMC is through VTABLEs, not attributes or methods. Luckily, VTABLEs exist that allow us to query the object for related attributes and methods, though the PMC itself may not necessarily respond to these requests.<br /><br />Using PMCs, Parrot does provide a proper Object system through the use of two special PMC types: Object and Class. Class, as can be guessed, is a "metaobject" that defines type information for objects of a single type. The Class uses a series of PMCs internally to manage things like method PMCs and attributes. The Object PMC is the basic building block of a class instance object. It provides a series of default vtables that allow it to interact with Class the way we expect (to find methods that are stored in the class reliably, for instance) and to provide a set of attributes that are available for access from PIR. PMCs are the almost formless building blocks, Object is a very specific PMC type that provides behaviors that we expect from an OO type system.<br /><br />Now that we've covered basic definitions, what are the big operational differences between the two systems? Here's a short list:<br /><br /><ol><li>Object types are defined by Class PMCs. PMCs are defined by PMCProxy PMCs</li><li>Class PMCs are created whenever we do a "newclass" or "subclass" operation from PIR. PMCProxy PMCs are created lazily, only when we actually need to introspect a built-in PMC type.<br /></li><li>Objects must be created from a Class, which means the Class PMC must exist before any Objects of that type can be created. PMCs can be created by themselves and <a href="http://trac.parrot.org/parrot/ticket/1473">generally</a> don't require instantiation from another PMC.</li><li>Objects have very regimented behavior: You can (<a href="http://trac.parrot.org/parrot/ticket/1487">and should</a>) expect certain things when you access a named attribute or named Method. In a PMC these behaviors may be overridden to do <a href="http://trac.parrot.org/parrot/ticket/1094">different</a> and unexpected things. Specifically, it can be very difficult to get access to named attributes on a PMC unless they are explicitly made visible from PIR (which can be a lot of work, and not a lot of PMC types <a href="http://trac.parrot.org/parrot/ticket/1442">do it completely</a>)</li><li>Inheritance between PMCs happens at the C level, so C-level attribute structures are merged together and made visible from C code. Inheritance between objects happens at the PIR level, method and attribute lists are combined and made visible as expected when accessed from PIR code. Inheritance from a PMC to an object is almost always broken, if you expect the attributes and methods from the PMC to magically become visible as attributes and methods on the Object. I've never seen inheritance from an Object to a PMC subclass, but I suspect it is broken even worse.</li><li>The VTABLEs in the Object PMC all provide an option to use a PIR-based override routine to implement the behavior. To do this, every VTABLE function in the Object PMC searches the associated Class for a similarly named VTABLE Sub PMC and, if one is found, calls that. PMC types almost never search for an override in the Proxy, and if you define one it will never be called (unless you specifically implement the logic to search for and execute it). On a related note the VTABLEs of an Object, because they are stored as PMCs in a Hash in the Class, can be modified at runtime. The VTABLEs of a PMC cannot be (well, I guess you <span style="font-style: italic;">could</span> change the pointer to call a different function if your C-foo is strong, but I would prepare for fire and brimstone. Also, I won't fix any "bugs" that arise from this misguided behavior). I estimate at least <a href="http://trac.parrot.org/parrot/ticket/1082">10% of reported bugs</a> or feature requests in Parrot come from the "this sucks worse than I would expect" behavior of subclassing Objects from PMCs. If you can get away with it, it is almost always better to delegate to a built-in type instead of inheriting from it directly. But, I can talk more about problems and workaround solutions like this in another post.<br /></li></ol>So there you have a guide to the differences between Objects and PMCs. PMCs are the low-level building blocks of an object system, and Objects are combinations of several PMCs and a large number of default VTABLEs to implement an expected set of OO behaviors. In a sense, Objects <span style="font-style: italic;">are </span>PMCs, but in another sense they really aren't.