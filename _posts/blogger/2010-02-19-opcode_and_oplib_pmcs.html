---
layout: bloggerpost
title: Opcode and OpLib PMCs
publish: true
categories: [PIR, PMC, Parrot]
---

A few days ago, after some discussion with NotFound and others on #parrot, I started a small branch to experiment with some new PMC types. The results of that work were the two new experimental PMC types <a href="http://trac.parrot.org/parrot/browser/trunk/src/pmc/opcode.pmc">Opcode</a> and <a href="http://trac.parrot.org/parrot/browser/trunk/src/pmc/oplib.pmc">OpLib</a>. The branch merged into trunk shortly after the <a href="/2010/02/16/parrot_210_released.html.html">2.1.0 release</a>, so now they are available--experimentally--for people to test and use.<br /><br />OpLib provides an introspective accessor layer over the interpreter's op table. The OpLib allows us to get a current count of the number of opcodes currently loaded in the system. It can also be used to return the index number of an opcode specified by name, or the name of an opcode given by it's number. On one hand it's important to hide these kinds of details from the average PIR user for reasons of backwards-compatibility and encapsulation. However, for the people writing PIR assemblers and disassemblers in PIR, the information is vital.<br /><br />These PMC types are read-only types. You can use them to read information about the opcodes in the system, but you can't manipulate that information. However, I'm not against that capability entirely. Imagine the ability to remap an op number to a new custom opcode at runtime. This would allow us to write tools that can attach to live PIR code such as memory usage analyzers, profilers, watchdog monitors, etc. Of course, in most cases this capability would horribly crash the program if used incorrectly, but in the right hands it has much potential. This, if it happens at all, is a long way off.<br /><br />These two PMC types are still immature but they, along with the ever-improving Packfile PMCs, are already starting to enable some <a href="http://trac.parrot.org/parrot/browser/trunk/examples/pir/make_hello_pbc.pir">cool new</a> <a href="http://code.google.com/p/winxed/source/browse/trunk/examples/packfile.winxed">applications</a>. We don't quite expose all the information yet that we need to do complete compilation or decompilation, and some <a href="http://trac.parrot.org/parrot/ticket/1468">improvements are needed</a> in Parrot itself to fill in some of the remaining gaps, but we are getting closer.<br /><br />Before the 3.0 release I think we will have a PIR/PASM compiler that runs on top of Parrot natively. This could be written in PIR, of course, or one of the other cool developing languages such as <a href="http://github.com/perl6/nqp-rx">NQP</a>, <a href="http://code.google.com/p/winxed/">Winxed</a>, or something else. With this, we could cut IMCC out of the loop almost entirely if we wanted. We could also easily come up with new assembly languages or language dialects for interacting with Parrot. My <a href="/2010/01/25/the_problem_with_pir.html.html">dislike for PIR</a> is not a secret, so the ability to come up with another, better, assembly language for working with Parrot is an idea that makes me very happy.