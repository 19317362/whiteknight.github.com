---
layout: bloggerpost
title: Parrot's Deprecation Policy
publish: true
categories: [Policy, Deprecation, Parrot]
---

Parrot user kthakore sent a <a href="http://lists.parrot.org/pipermail/parrot-dev/2010-June/004423.html">very interesting email</a> to the Parrot developers list this week to criticize the current deprecation policy. After taking some time off from development, he returned to find that his extension no longer built on Parrot HEAD and he couldn't quite figure out why. There <a href="http://trac.parrot.org/parrot/changeset/47190/trunk/DEPRECATED.pod">was a deprecation notice for the feature that changed</a>, but the notice was so vaguely worded and so short on explanation that it offered very little help to the beleaguered extension developer.<br /><br />When we're talking about code, there are only a handful of things that we really need to worry about: utility, performance, security, stability and maintainability. Well-written code, for the most part, can satisfy all these requirements. Sometimes trade-offs are made, such as trading a certain amount of maintainability to optimize for performance, but in those cases some well-placed comments can help alleviate or minimize any regressions. Code, while technical and deep, is often pretty easy: we follow rules and policies, make changes, measure results, wash, rinse, repeat.<br /><br />Not so easy are the softer sides of open source software: the people. People come in varieties: core developers, extension developers, testers, documenters, end-users and well-wishers of varying levels of technical competency. Keeping all these groups of people working together nicely and happily can be quite a difficult challenge, and there is likely no way for all groups to be 100% happy 100% of the time. The tradeoffs here are harder to understand, harder to manage, and a misstep can have huge negative consequences for the project.<br /><br />I've long been a detractor of Parrot's <a href="http://trac.parrot.org/parrot/browser/trunk/docs/project/support_policy.pod">current deprecation policy</a>: It's too rigid, too narrow, and doesn't really do anything to help the people who need helping. It also doesn't really take into account Parrot's current stage in the development life cycle. Parrot, as I've mentioned on occasion, has <a href="/2010/05/19/bright_blue_yonder.html.html">plenty of warts</a> and has suffered many <a href="/2010/05/21/the_fitness_of_parrot_as_a_target_platform.html.html">growing pains</a>. It is folly to think that we should be making blanket guarantees about what <a href="/2010/01/22/parrot_20_personal_retrospective.html.html">will or will not be present in various releases</a>, or how quickly we can or cannot make changes.<br /><br />When there's a problem or a bug or a misfeature, people want those things fixed quickly. A good example of this were the <a href="/2009/10/21/pcc_branch_lands.html.html">PCC refactors a few months ago</a>. Even though those refactors created some backwards-incompatible behavior our users (who the deprecation policy was at least nominally designed to protect) were trying to <a href="/2009/10/05/pcc_hackathon_day.html.html">rush them through</a>. Rakudo developers specifically were blocking on the PCC improvements and having to wait for months and months would have been bad for them. The PCC refactors were high priority and high need.<br /><br />The deprecation of several core ops and their conversion to dynops recently is an example from the other end of the spectrum (and the source of kthatkore's frustration). While we followed the letter of the deprecation policy, these things didn't <i>need</i> to be removed with haste and created a bit of hassle for users who weren't expecting it. I'm not saying they shouldn't have been removed (I'm always <a href="/2010/03/18/lean_and_mean_parrot.html.html">a proponent of removing cruft</a>), but it does expose some short-comings of our deprecation policy and process.<br /><br />What we have is a series of conflicting motivations, even for individual groups. Consider:<br /><ul><li><b>Core Developers</b>: Core developers want to remove bad features, want not to maintain bad features, want to add new good features and want to create the best software for the users. Developers need to work on fun new features, but also need their work to be used and appreciated. Take away either of those pieces, and many volunteer developers will simply walk away. Moving too quickly alienates the users and creates a huge disconnect between what the developers are developing and what the users are actually using. Moving too slowly is boring and developers start to leave for greener pastures.</li><li><b>Extension Developers</b>: Want to add new extensions to the Parrot ecosystem for the benefit of users, but have to deal with binary compatibility at the C level which changes much more frequently than the "normal" user-visible interfaces like PIR. Parrot has a lousy extension API right now, so necessary improvements there require extension developers to stay up-to-date with current core development. At the same time, all sorts of other changes break things in new versions, even when necessary features are fixed. </li><li><b>Users</b>: For stability, it's good for users not to upgrade. To fix bugs and get new features, it's good t upgrade. Upgrading brings rewards but also hassles:Â  Core features disappear, new bugs are added, and extensions are broken by binary incompatibilities. Upgrading Parrot means needing to upgrade (or, at least, rebuild) extensions too.</li></ul>It's difficult to tell an extension developer to stick to the supported releases because the extending API is so lousy and incomplete. Having to wait 3 months or more for a necessary change is hard for these small projects, and their developers can quickly lose interest and motivation. Until we reach some basic level of usability, we have to expect that extension developers are going to be tracking Parrot HEAD more or less closely. I think it's a little disingenuous to simultaneously expect fully that developers will be tracking the repository HEAD but also write in our deprecation policy that they should only track the stable releases, and you really need to ask who exactly that policy is designed to protect in this case.<br /><br />We really need to account for different levels of user and different levels of feature. End-users shouldn't be using Parrot directly. Joe Schmoe at home is not and definitely <a href="/2010/01/25/the_problem_with_pir.html.html">should not be writing his tools in PIR</a>. If he's writing his code in a higher-level language like Rakudo Perl 6, NQP, or Winxed, he's buffered from disruptive changes made to the Parrot core VM. It's the developers of HLL compilers and extensions that need to worry about these kinds of changes.<br /><br />Likewise, we need to differentiate between issues of multiple severities.When a big issue is blocking development in extensions and HLL compilers, it behooves Parrot to ignore the mandatory wait period and to make those fixes post haste. Alternatively, a change which is not necessary and would cause a block or a slow-down for extension developers should be put off for longer and made with more care.<br /><br />What we need, in a nutshell, is a policy that actually does what we claim the current deprecation policy does now: <b>Protect our users from disruptive changes</b>, but also <b>enable forward progress to be made without being forever tied to every bad decision ever made</b>. I suggest these changes to policy and process:<br /><br /><ol><li>Deprecation should be added before a disruptive change is made </li><li>The deadline for the deprecation shouldn't be blindly tied to the next stable release, but <b>intelligently selected with input from the affected parties</b>. We do have weekly planning meetings where these kinds of things can be decided. If we need to regularly schedule additional meetings with other parties (HLL compiler devs, extension devs, etc) we should do that as well.</li><li>Deprecations should be well-documented and publicized. Information about the deprecation should include what exactly is changing, how users of those features can work around the changes, and who to contact when/if problems arise.</li><li>Information about the deprecation should be sent to the users, not just dumped in DEPRECATED.pod where we expect people to be looking regularly. An email list for this purpose was suggested and I like that idea (other ideas were also suggested that I also like). Any way to send the information directly to the user is a good thing. </li><li>Where possible, both old and new versions should <a href="http://lists.parrot.org/pipermail/parrot-dev/2010-June/004430.html">be provided simultaneously</a> for a period of time while users transition. This is most important in the C-level API where function wrappers can easily be provided to translate old calls into new ones.</li></ol>I'm still a big proponent of the idea that the deprecation policy should be opt-in, in the sense that only features that we've put a stamp of approval onto should be covered under the deprecation policy and anything else should not be relied upon. You <i>can</i> use a feature that we haven't approved, but then you're responsible for paying the price when that feature changes or disappears completely. You would also be responsible for sending the core developers feedback about which features you would like to see be added and approved.<br /><br />Having a deprecation policy is a good thing and a necessary part of a mature software project. However, the policy we have currently fails on a number of counts and requires some serious re-thinking if we want to make it better. I sincerely hope, and I know several other people also hope, that we do make it much better in the future.