---
layout: bloggerpost
title: Fixed-Size Allocator: Now With Extra Working!
---

A few days ago I toggled the flag to disable the <a href="http://wknight8111.blogspot.com/2009/08/fixed-size-allocations-for-parrot.html">fixed-size allocator</a>. I was receiving too many bug reports that I wasn't able to debug adequately, and I heard that it wasn't working at all on Win32. So we shut it down in hopes that we could find a fix eventually. Well, today I found and committed the fix.<br /><br />NotFound mentioned out of the blue today that the fixed-size allocator <span style="font-style: italic;">was working</span> on Linux, both 32- and 64-bit flavors. This was news to me, last I had heard it was malfunctioning on those platforms. However this news was quickly confirmed by darbelo too, and then I did it myself. Worked perfectly. So I crossed my fingers and tried on Win32 as well: Nothing. Segfault during miniparrot and the build stopped. I don't have GDB on my windows machine (it's actually my work computer, so it's use is limited). I do have Visual Studio, but I've yet to find a real way to debug a program in VS that I didn't build in VS, especially if it's a native-code executable. In lieu of real debugging tools, I used the "printf" method to try and narrow down where and when the segfault was happening. Here's the function that was causing problems, can you spot the error?<br /><pre><br />PARROT_CANNOT_RETURN_NULL<br />PMC_Attribute_Pool *<br />Parrot_gc_get_attribute_pool(PARROT_INTERP, size_t attrib_size)<br />{<br />   ASSERT_ARGS(Parrot_gc_get_attribute_pool)<br />   Arenas * const arenas = interp->arena_base;<br />   PMC_Attribute_Pool ** pools = arenas->attrib_pools;<br />   const size_t size = (attrib_size < sizeof (void *))?(sizeof (void *)):(attrib_size);<br />   const size_t idx  = size - sizeof (void *);<br /><br />   if (pools == NULL) {<br />       const size_t total_length = idx + GC_ATTRIB_POOLS_HEADROOM;<br />       const size_t total_size   = (total_length + 1) * sizeof (void *);<br />       /* Allocate more then we strictly need, hoping that we can reduce the<br />          number of resizes. 8 is just an arbitrary number */<br />       pools = (PMC_Attribute_Pool **)mem_internal_allocate(total_size);<br />       memset(pools, 0, total_size);<br />       arenas->attrib_pools = pools;<br />       arenas->num_attribs = total_length;<br />   }<br />   if (arenas->num_attribs <= idx) {<br />       const size_t total_length = idx + GC_ATTRIB_POOLS_HEADROOM;<br />       const size_t total_size   = total_length * sizeof (void *);<br />       const size_t current_size = arenas->num_attribs;<br />       const size_t diff         = total_length - current_size;<br /><br />       pools = (PMC_Attribute_Pool **)mem_internal_realloc(pools, total_size);<br />       memset(pools + current_size, 0, diff * sizeof (void *));<br />       arenas->attrib_pools = pools;<br />       arenas->num_attribs = total_length;<br />   }<br />   if (pools[idx] == NULL)<br />       pools[idx] = Parrot_gc_create_attrib_pool(interp, size);<br />   return pools[idx];<br />}<br /></pre><br />We keep an array of pool structures ("<code>pools</code>"), where each index into that array represents the size of the object managed by that pool. The smallest object we can allocate is a single pointer, because we link objects together into a linked list, so we need at least enough space for one pointer to handle that. We also want indexing for the smallest items (<code>sizeof(void*)</code>) to start at slot zero in the pools array to save space. To get this effect, we first calculate the minimum necessary size of the object, and then we subtract the <code>sizeof(void*)</code> from that to give us the index into the pools array. This part works just swell.<br /><br />We then have two large logic blocks. The first determines whether we have allocated any pools at all, and if not first allocates space for the pools array. The second block determines if we have too few slots allocated, in which case the array is resized to accommodate our incoming request. We then check to see if the current slot is null, and allocate a new pool in that slot if it is. Finally we return the pool in the given slot.<br /><br />The problem, I soon found out, was that for some specific sizes we were returning bad pointers. See the problem yet? Let's zoom in a little:<br /><pre><br />const size_t total_length = idx + GC_ATTRIB_POOLS_HEADROOM;<br />const size_t total_size   = total_length * sizeof (void *);<br />/* Allocate more then we strictly need, hoping that we can reduce the<br />  number of resizes. 8 is just an arbitrary number */<br />pools = (PMC_Attribute_Pool **)mem_internal_allocate(total_size);<br />memset(pools, 0, total_size);<br />arenas->num_attribs = total_length;<br /></pre><br />This is part of the logic for allocating a fresh pools array. <code>GC_ATTRIB_POOLS_HEADROOM</code> is a buffering factor I added. It's <code>#define</code>'d to be 8, which means that when we do allocate we make space for 8 sizes more then we currently need. This prevents us from needing to resize the array if we need to allocate an object that is only a little bit bigger (and we know that we will almost always need to allocate something that's just a little bigger).<br /><br />Taking the index (<code>idx</code>) of the slot, we calculate the size of the array, allocate it, then initialize it all to zero. Except we don't. In the first run through if <code>idx</code> is 0 then <code>total_length</code> is 8 and <code>total_size</code> is 64. This means we're allocating enough space for 8 pointers, not one pointer plus a headroom of 8 additional pointers. Because the <code>idx</code> is zero-based, my math here was off by one. To see it better, consider if <code>GC_ATTRIB_POOLS_HEADROOM</code> was omitted entirely. Then <code>idx</code> would be 0, <code>total_length</code> would be 0, and <code>total_size</code> would be 0. Try passing that to <code>malloc</code> and see how well it works for you.<br /><br />So I changed the calculation for <code>total_size</code> to:<br /><pre><br />const size_t total_size   = (total_length + 1) * sizeof (void *);<br /></pre><br />And Parrot magically started building on Win32. A few more small cleanups and I committed <a href="https://trac.parrot.org/parrot/changeset/40962">r40962</a>.<br /><br />I still need to do some benchmarking though, I'll try to do that tonight. I hope that this will bring some measurable performance improvements to Parrot.