---
layout: bloggerpost
title: Proposal to Change find_method
publish: true
categories: [Parrot, Objects]
---

Austin Hastings, as part of his <a href="http://gitorious.org/kakapo/kakapo">Kakapo project</a> (which I now have a <a href="http://gitorious.org/%7Ewhiteknight">commit bit to</a>!) has started creating a <a href="http://gitorious.org/kakapo/kakapo/blobs/master/src/Mimidae/Maker.nqp">mock object framework</a>. We were talking about how to implement expected method calls, so I took a look at the find_method VTABLE of the <a href="http://trac.parrot.org/parrot/browser/trunk/src/pmc/object.pmc">Object PMC</a> for some inspiration. What I saw was absolutely horrible, so I promptly created a branch to fix it. However, the more I looked and edited, the bigger I found the problems to be. I'll talk more about Kakapo in another post.<br /><br />When I do code like this:<br /><pre><br />$P0 = new ['Foo']<br />$P0.'Bar'()<br /></pre><br />What is really happening is something similar to this:<br /><pre><br />$P0 = new ['Foo']<br />$P1 = find_method $P0, 'Bar'<br />callmethodcc $P0, $P1<br /></pre><br />Internally, the find_method opcode calls the VTABLE_find_method function on the given object. The object itself is expected then to walk the method resolution order (MRO) of it's inheritance hierachy to find a suitable method and return it. Along the way, the Object PMC needs to completely violate the encapsulation of the Class PMC to gather information about the MRO and then to search the list of methods in the Class for an entry with the given name. In short version, the C code from Object.find_method looks like this:<br /><pre><br />int num_classes = VTABLE_elements(interp, class->all_parents);<br />int i;<br />for (i = 0; i < num_classes; i++) &#123;<br /> cur_class = VTABLE_get_pmc_keyed_int(interp,class->all_parents, i);<br /> if (VTABLE_exists_keyed_str(interp, class->methods, name))<br />    return VTABLE_get_pmc_keyed_str(interp, class->methods, name);<br />&#125;<br /></pre><br />So Object reads the attributes of it's Class PMC directly, and manually traverses the MRO looking for the proper method. This causes a few problems. First, as a mostly stylistic point, this completely breaks encapsulation. We can't make a change to the MRO or the method storage and lookup mechanism in Class without likewise changing the behavior in Object.<br /><br />Second point, since Object needs to know how to traverse the MRO and lookup methods, and requires intimate internal knowledge of the classes in the MRO, we are extremely limited in the types of objects that can be in the inheritance hierarchy. That is, we can't define our own metaobject types, we <span style="font-style: italic;">must</span> use Class or PMCProxy, or a subclass thereof (and a careful reading of the code suggests that even subclasses will not work). This seems to be a remarkable limitation when you consider some of the diverse high-level languages that Parrot aims to support.<br /><br />One thing I tried to do was create a find_method VTABLE in the Class PMC, and then delegate traversal of the MRO to Class instead of Object. This helped improve encapsulation greatly, but created another problem: Now I couldn't call methods on Class itself. Here's example code that broke:<br /><pre><br />$P0 = getclass 'Foo'<br />$P0.'add_vtable_override'("bar")<br /></pre><br />What we want to do is call a method on the class object itself, but what we end up doing is finding a method on <span style="font-style: italic;">objects of that type</span>, and then trying to call that method on the class object. Problems.<br /><br />Let's recap some issues:<br /><ol><li>Find_method searches for a method to use on a given invocant</li><li>The Class type has methods that need to be accessible through find_method</li><li>Object has to break encapsulation and monkey around in Class's internals, which means we can <span style="font-style: italic;">only use Class</span> objects, and objects strictly isomorphic to Class (like PMCProxy) in an MRO</li><li>We cannot delegate the method lookup operation to the Class object, where it arguably belongs.</li></ol>With these things in mind, I had an idea that <a href="http://lists.parrot.org/pipermail/parrot-dev/2010-February/003891.html">I sent to the list</a> which aims to fix all this: Create a new VTABLE function that searches for a method in a metaobject, instead of searching for the method on the invocant (like find_method does now). In terms of PIR, I'm thinking of enabling this kind of sequence:<br /><pre><br />$P0 = new ['Foo']<br />$P1 = getclass 'Foo'<br />$P2 = find_class_method 'Bar'<br />callmethodcc $P0, $P2<br /></pre><br />I don't want to remove find_method or change it in any way. But what I want to have is a way to delegate method lookup to the Class object as well. I think we will find that when we have a way to delegate lookup to the Class object that we will use it much more frequently and to greater effect than we use find_method now. I also think we will find that find_method can eventually be deprecated entirely, but that's another issue for another time.<br /><br />One other problem that I failed to mention above is that every class has it's own completely linearized resolution order. So if Foo is a Bar, and Bar is a Baz, the Foo class has the MRO ("Foo", "Bar", "Baz"), Bar would have the MRO ("Bar", "Baz"), and Baz would have the MRO ("Baz"). Asking the Foo Class object for a method "Frobulate" would look in Bar, which would ask Baz. Then, Foo would move to the next item in it's MRO, Baz, and ask it. The net result is that Baz would be queried twice, since the Foo Class item doesn't know necessarily that Baz is in Bar's MRO, and Bar doesn't know that it is being queried from Foo (maybe Bar was being queried directly). So what we need is some kind of way to keep track of the MRO up front, and avoid re-defining the search MRO for each new delegation.<br /><br />I think we could solve this issue if we defined a new VTABLE like this:<br /><pre><br />VTABLE PMC * find_class_method(STRING *name, PMC *mro_iterator)<br /></pre><br />In this conception, SELF would be the metaobject currently being searched, name would be the string name of the method to find, and mro_iterator would be an iterator object for the MRO list. When we do the PIR code:<br /><pre><br />$P0 = getclass "Foo"<br />$P1 = find_class_method $P0, "Frobulate"<br /></pre><br />The first call to the Foo class object would be <code>VTABLE_find_class_method("Frobulate", NULL)</code>. Foo would then create an iterator over it's MRO (removing itself from the front of the list to avoid direct recursion) and passing that MRO iterator to Bar, which then calls the next item on the list (Baz). This has a few major advantages which are not necessarily obvious up front: Any object that defines find_class_method can be inserted into the MRO. This includes things that aren't really classes like Roles, Mixins, extension methods, and even autoloaders. Second, we gain more flexibility to modify the MRO of a class, because that class (and it's super-classes) can add additional search parents to the iterator as needed. We would also gain the ability to have more manual control over the MRO, because we could add a find_class_method_p_p_s_p op variant that also takes an existing MRO iterator. This would enable us to better implement something like a super() call, where we take the MRO iterator, manually pop the top item off it, and then call find_class_method with it. I've got several bonus points available to whoever can explain how to call a method in a super class when it's overridden in the subclass, without having to hard-code in the name of the parent class. With the new VTABLE and a new op, this becomes trivial.<br /><br />So that's my idea for method lookups. I've sent a mail to the list with the idea, and I'm going to raise the idea at #ps if I can make it to the meeting. I think it has a lot of merit, enables a few cool new abilities and doesn't take away any existing functionality. I would like to hear any other ideas, but I'm becoming convinced that this one is a winner.
                <div class='old-blogger-comments'>
                    <h2 class='old-comment-header'>Comments</h3>
                
<div class='blogger-comment-div'>
    <a name='2609441915459718512'></a>
    <p class='blogger-comment-body'>
        Actually, Kakapo already does super(), without hard-coding the method name. :)
    </p>
    <div class='blogger-comment-author-div'>
        <span class='blogger-author-sig'><a class='blogger-author-uri' href='http://www.blogger.com/profile/13284330930068467507'>Austin</a>
</span>
        <span class='blogger-comment-datestamp'>
            <a class='blogger-comment-link' href='{{ post.url }}#2609441915459718512'>
                2/28/2010 5:19:22 PM
            </a>
        </span>
    </div>
</div>

<div class='blogger-comment-div'>
    <a name='7631724537610924916'></a>
    <p class='blogger-comment-body'>
        Ah yes, I see that code gem now. Of course, Austin didn't explain it!<br /><br />What Kakapo does is exactly what I suggest Parrot should be doing internally: He gets the MRO from the Class, iterates it himself, and searches for the method with the given name manually. <br /><br />Considering that super() is such a common and necessary operation in most object-oriented lanuages, it's surprising that it takes this much effort to do it. Parrot should be managing the MRO automatically (with, of course, plenty of flexibility to plug in custom schemes).
    </p>
    <div class='blogger-comment-author-div'>
        <span class='blogger-author-sig'><a class='blogger-author-uri' href='http://www.blogger.com/profile/16207472474429254890'>Whiteknight</a>
</span>
        <span class='blogger-comment-datestamp'>
            <a class='blogger-comment-link' href='{{ post.url }}#7631724537610924916'>
                2/28/2010 6:15:30 PM
            </a>
        </span>
    </div>
</div>
</div>
