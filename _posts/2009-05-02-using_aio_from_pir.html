---
layout: bloggerpost
title: Using AIO from PIR
---

Last time <a href="http://wknight8111.blogspot.com/2009/05/aio-variants.html">I talked a little bit about</a> how AIO would probably be implemented in PMC form, where each request or event was encapsulated in various PMC types. Let's take a quick look to explore how these might be used from PIR code.<br /><br />First, a polled write:<br /><code><br />  .local pmc request<br />  request = new 'AIOWriteRequest'<br />  say request, "Hello World!"<br />poll_loop_top:<br />  unless request goto poll_loop_top<br />  say "Done!";<br /></code><br />This would be, coincidentally, a way to implement a blocking call to the "say" opcode, in terms of an asynchronous variant. Of course, we would probably write it in C, but the steps would be the same. Now let's look at the same kind of idea, but using a callback to restore control flow instead of a polling loop to stall:<br /><code><br />  .local pmc request<br />  request = new 'AIOWriteRequest'<br />  .local pmc continue<br />  continue = new Continuation<br />  set_addr continue, resume_point<br />  request.set_callback(continue)<br />  say request, "Hello World Again!"<br />  end<br /><br />resume_point:<br />  say "Done!"<br /></code><br />A lot of this is speculative, I don't really know what would be considered the best way to halt the current execution thread but allow a scheduled task to continue execution later in the future. The "end" opcode is probably not a good one for this use, but I don't think any others exist. In either case, we probably want some kind of guarantee internally that all outstanding IO requests (besides a passive "listen") will be handled prior to interpreter termination, so calling "end" with an outstanding IO request could cause execution to resume as we expect. Again, speculative. Regardless of the specific details, this method performs the same blocking "say" call, but has the added benefit that it's not looping endlessly and eating resources the entire time. The currently running thread simply stops, and Parrot is free to use that time to do other work (such as handle the IO call).<br /><br />I'm also ignoring some details about how buffering would work. For instance, if we were writing lots of little snippets to a file in a loop, would we buffer multiple snippets together into a single request, or would we dispatch each separately. Would we write:<br /><code><br />loop_top:<br />  $S0 = 'get_next_snippet'()<br />  print requestobj, $S0      # Add $S0 to the buffer<br />  unless ready_to_exit goto loop_top<br />  schedule requestobj        # Start the write operation with all snippets<br /></code><br />Or maybe:<br /><code><br />loop_top:<br />  $S0 = 'get_next_snippet'()<br />  print requestobj, $S0      # Set the payload<br />  schedule requestobj        # Schedule it, one snippet at a time<br />  unless ready_to_exit goto loop_top<br /></code><br />Obviously lots of questions to answer as we talk about implementing this system. One thing you will notice in the two previous examples, but you did not see in the first two was the use of the "schedule" opcode to actually dispatch the requests. For something like an asynchronous write operation, would the "say"/"print" opcodes actually schedule the IO, or would they just write data to the request buffer and then the "schedule" opcode would schedule it? Lots of questions to answer.<br /><br />Let's look now at a passive listening PMC, such as a socket connection that would receive incoming data, or a PMC that listens to the OS to receive filesystem events:<br /><code><br />  .local pmc listener<br />  listener = new 'AIOListen'<br />  .local pmc callback<br />  callback = find_global 'callback_sub'<br />  listener.set_callback(callback)<br />  listener.listen()     # Could also be "schedule listener"<br />  ...<br /></code><br />Every time the listener PMC received input, it would pass it along to the callback function:<br /><code><br />.sub 'callback_sub'<br />  .param pmc aiolisten    # The AIOListen object<br />  .param string data      # The incoming data<br />  ...<br /></code><br />In all the examples I've obviously left out some details. For instance, on none of the objects did I specify a filename or streamname, nor did I specify anything like a timeout, and I certainly didn't talk at all about buffering. Those details are necessary, but not important for these examples.<br /><br />Here's another idea: What if instead of PIR-exposed AIO PMCs we had opcodes that managed these requests automatically?<br /><code><br />  writerequest filehandle, "Hello World!", callback1<br />  readrequest filehandle, 20, callback2<br /></code><br />And maybe an optional fourth argument would specify whether the current executing thread should suspend, terminate, or continue while the request is executing (which would enable us to do blocking IO very simply.<br /><br />So these are some conceptual ideas about how AIO would be usable from PIR code. I'd be very interested to hear ideas that other people had about how it could be used. What I would like to see is example code that people think should work. <span style="font-weight: bold;">Show me what you think these code examples should look like</span>. There isn't anything firm on the design board yet, although I have a few more blog posts left to write about this topic.