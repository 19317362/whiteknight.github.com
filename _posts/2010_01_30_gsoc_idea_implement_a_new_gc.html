---
layout: bloggerpost
title: GSoC Idea: Implement a new GC
---

Blah Blah Blah Parrot needs a new GC. Blah Blah the current GC is lousy Blah Blah.<br /><br />I've said it all before. At length. Ad nausea. Hell, I even attempted this same GSoC project myself two years ago.<br /><br />The garbage collector is one of those systems that absolutely effects almost every aspect of Parrot's operation and performance. A bad GC means a slow, obnoxious VM with pauses and huge memory consumption. Of course, there is no one single "best" GC algorithm to use that provides optimal behavior to all classes of programs. This is why Parrot was designed to have a pluggable GC system where the most pertinent GC from among multiple options can be selected.<br /><br />At least, that's the theory.<br /><br />Parrot really only has one GC right now and it's a very simplistic Mark and Sweep collector with some less-than-desirable properties. bacek has been making good progress on porting the <a href="http://wknight8111.blogspot.com/2010/01/boehm-in-parrot.html">Boehm GC to Parrot</a>, but that has it's drawbacks as well (though drawbacks are being mitigated). What we need is more people working on it, more people trying new things, and more eyes on the code.<br /><br />So what kinds of GC could Parrot use? The <a href="http://trac.parrot.org/parrot/wiki/BigProjectIdeas">projects page on the wiki</a> describes three types that Parrot is specifically interested in:<br /><ol><li>Generational</li><li>Incremental</li><li><a href="http://wknight8111.blogspot.com/2009/06/concurrent-garbage-collection.html">Concurrent</a></li></ol>These adjectives are not orthogonal, you could easily have an incremental-concurrent collector, or a generational-incremental collector, or even a generational-incremental-concurrect collector. But, these three things <a href="http://wknight8111.blogspot.com/2009/08/parrottheory-garbage-collection.html">tend to have nice properties</a>.<br /><br />Generational collectors tend to have nice throughput because we subdivide the memory space and only take the time to mark and sweep a subset. Incremental collectors break the mark and sweep phases up into smaller increments which in turn decrease pause times. Concurrent collectors utilize multiprocessor systems to operate the GC in parallel with the program code and therefore experience no pauses and high throughput (but lousy performance on single-processor systems, or multiprocessor systems with many other running processes).<br /><br />The aspiring GSoC student working on GC will benefit from two years of hard cleanup and refactoring work <a href="http://wknight8111.blogspot.com/2009/05/gc-next-steps.html">from myself</a> and other contributors. Plus, there is <a href="http://wknight8111.blogspot.com/2009/12/gc-gets-kick-start.html">strong community support</a> to get a new GC up and running as quickly as possible to replace our current one. It's a project that will be tough no matter what, but where there are huge gains to be made for the Parrot community and a large amount of available support.<br /><br />As I mentioned above, the GC system is supposed to be pluggable. So in reality you don't need to implement a great GC that will solve all our problems, you just need to implement <span style="font-style: italic;">any</span> GC to prove that the system is, indeed, pluggable. If the GC you implement has some nice properties that's just a nice bonus.