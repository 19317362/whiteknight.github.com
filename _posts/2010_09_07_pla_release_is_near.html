---
layout: bloggerpost
title: PLA Release Is Near
---

I added in support for HLL mapping of autboxed types in <a href="http://github.com/Whiteknight/parrot-linear-algebra">Parrot-Linear-Algebra</a>, and with that I feel like I'm getting pretty close to a good point for cutting a release. I don't yet have any tests for the autoboxing behavior, so I do need to write those first. Shortly thereafter I think I can get to work on the release.<br /><br />HLL mapping, for readers who may not be familiar with the term, is a very cool feature in Parrot. It allows the user to manually re-map basic types to user-defined types instead of the built-in varieties. When the VM would normally create an Integer PMC, for instance, it would instead create a custom "MyInteger" type (or whatever you called it). You can use the HLL mapping functionality to override many built-in types in many operations. What's super-cool about HLL mapping is that the mapping is defined in a particular HLL namespace, so programs with modules written in different languages could allow each module to define it's own type mappings that do not conflict with each other.<br /><br />In Parrot, an "HLL namespace" is a special type of top-level namespace object which allows the use of type mappings, among other things. In PIR code, defining an HLL is simple with the .HLL directive:<br /><br /><pre>.HLL "MyLanguage"<br /></pre><br />All regular namespaces defined below that directive will be inside the HLL namespace. This means that so long as we make proper use of .HLL directives, we can maintain almost perfect encapsulation between modules written in different languages, which can be an extremely valuable thing for proper interoperation.<br /><br />The default HLL is called "parrot". If you don't specify an HLL directive, you will automatically be inside the "parrot" HLL namespace. To get back to there, you can type (in PIR):<br /><br /><pre>.HLL "parrot"<br /></pre><br />I started writing some tests on Saturday, and discovered two problems that brought me to a halt: First, NQP doesn't have any built-in way to specify an HLL namespace. I also wasn't able to find any crafty, sneaky way to inject one either. Second, HLL type mapping doesn't work in the parrot namespace.<br /><br />The second problem turned out to be the most frustrating because the test programs I was writing were silently failing for no visible reason. The mapping method appeared to execute and return correctly, but none of my types were being mapped. Dutifully, <a href="http://trac.parrot.org/parrot/ticket/1771">I filed a bug about it</a>. It turns out that this is by design, not accident, although I wish that it had been a little bit better documented. HLL mapping lookup operations can be a little bit expensive, so we don't want to be doing that all the time. Also, the parrot HLL is supposed to be a default, neutral space and one module shouldn't be able to break encapsulation and modify that HLL namespace in a way that would adversely affect other modules written in other languages. NotFound put together a commit that throws an exception when a type mapping is attempted in this HLL, so that allays my concerns that not only was it failing, but it was failing silently.<br /><br />I also started <a href="http://github.com/Whiteknight/nqp-rx/commit/0156e5d76bafea8d87d0db8b8790ab15311f93b5">putting together a patch in my fork</a> of NQP-RX that adds HLL support, but the patch isn't very mature yet. If I can get this patch ready and merged into NQP-RX master in time for the 2.8.0 release, I will write up the last remaining PLA tests for this feature in NQP. Otherwise, I will write them in PIR.<br /><br />The PLA release is going to target Parrot 2.8.0. There are a few things that I want to do first, before the release is out the door:<br /><ol><li>Finish writing the tests for the HLL mapping behavior, which might involve finishing up that patch to NQP</li><li>Write up some decent public documentation. The default output of pod2html is pretty ugly looking, so I may end up writing a custom converter. I've started experimenting with Github Pages, though my experiments so far in using the pod2html output there have not been too attractive. I may go through and reorganize all the POD documentation source anyway. I definitely want to expand documentation and examples of certain features.</li><li>Get a release, or pseudo-release of <a href="http://gitorious.org/kakapo/kakapo">Kakapo</a> that targets Parrot 2.8.0. If Austin isn't able to get a working release of that software that's up to his standards in the next two weeks, I may pick a revision that works well for my purposes and tag it on <a href="http://github.com/Whiteknight/kakapo">my Github fork</a>. It won't be the same as a real release of Kakapo, but at least it won't be a stumbling block for me.</li><li>I need to check and double-check that the setup script for PLA is doing all the correct things with respect to releasing. I need to check that the generated <a href="http://gitorious.org/parrot-plumage/parrot-plumage">Plumage</a> metadata is correct and allows complete and functional installations using Plumage. I also need to check that I can generate correct .deb and .rpm packages for those systems.</li><li>I want to look into creating a windows installer, but I make absolutely no promises about that. I certainly haven't done any testing whatsoever on Windows so far, and I do not have high hopes that it will work at all there. This may be a task for the next release, or later.</li></ol>In the span of about two weeks, we could have a release of a high-performance linear algebra toolkit for Parrot. It obviously doesn't have a huge amount of functionality yet, but it is a good start and provides a solid base of some important standard operations. I've got a lot of plans for the future of this little project, but we're at a good point right now and I think it will make for a very nice release.
                <div class='old-blogger-comments'>
                    <h2 class='old-comment-header'>Comments</h3>
                <div class='blogger-comment-div'>
                <p class='blogger-comment-body'>
                    Rakudo uses 'parrot-nqp --target=pir' to compile its compiler NQP to PIR, then '.include's the resulting PIR into files with .HLL declarations at the top.<br /><br />-sorear
                </p>
                <div class='blogger-comment-author-div'>
                    <span class='blogger-author-sig'>Anonymous
                    <span class='blogger-comment-datestamp'>
                        9/8/2010 3:11:21 AM
                    </span>
                </div>
            </div>
            </div>
