---
layout: bloggerpost
title: Sized Pools in the GC
---

There are three kinds of things in parrot that the garbage collector currently deals with: PMCs, STRINGS, and "bufferlike" objects. Bufferlike objects are things that are isomorphic with PObjs, so their definition starts like this:<br /><pre><br />typedef struct <bufferlike> &#123;<br />   UnionVal cache;<br />   UINTVAL flags;<br />   ...<br />&#125;<br /></bufferlike></pre><br />The UnionVal structure is slowly disappearing, they have recently been deprecated and made unused in PMCs for a variety of reasons. The GC expects everything that it interacts with to conform to this pattern. Specifically, the <code>flags</code> field is important because that contains information that tells what the PObj is and how it is handled by the GC. So a PMC will have an "is PMC" flag set, a STRING will have an "is STRING" one instead. PMC types that define a custom <code>VTABLE_destroy</code> will have the "needs custom destroy" flag set, so the GC knows to call it's destructor. There are a few other flags that are relevant to the GC here too, and several flags which are not relevant to the GC, I'm just giving a small sample.<br /><br />Bufferlike objects are things that look like these PObjs, but aren't PMCs or STRINGs. They can be any size, Parrot has an infrastructure called the "sized pools" to allow orderly allocation of these objects from pools of all like-sized objects. There are some good and bad points with this. The good is that memory we allocate from the system in chunks and we allocate ourselves is intrinsicly faster then having to call <code>malloc</code>/<code>free</code> all the time. It also helps that these types of objects are managed by the GC instead of having to manually allocate and deallocate them, or having to perform a custom reference counting on them. The bad news is that there are currently only two types of objects that are allocated from these sized pools: Stack chunks and List chunks. If I remember correctly it is the long-term goal to remove the dynamic stack from Parrot entirely, so eventually we might be left with only the List chunks being allocated from the sized pools, and if that's all we have it's not worthwhile to maintain a separate infrastructure for them.<br /><br />As I mentioned before, there are two factors we should keep in mind when allocating memory:<br /><br />1) Using <code>malloc</code> to allocate memory from the OS is a bad thing for performance. This is because <code>malloc</code> is a general allocator that must be able to allocate objects of various sizes. Lots of transactions can lead to memory fragmentation and linear slowdowns as the heap is searched for a new buffer of the specified size. ALso, there are performance drains every time we call into the kernel, although that isn't so dramatic.<br />2) Allocating and managing memory from pools of like-sized objects can be a big performance win and is algorithmically simple to do.<br /><br />That said, for almost all memory allocations in Parrot that are reasonably small and fixed-size, we should be attempting to allocate them through managed fixed-size pools instead of allocating them directly from the system. However, this isn't what we do. The fixed-size pools are reserved for "bufferlike" PObj isomorphs and all other objects are malloc'd.<br /><br />Consider also a pattern that is very common in many of our core PMCs:<br /><pre><br />VTABLE void init(void) &#123;<br />   Parrot_ThisPMC_attributes *attrs =<br />       mem_allocate_typed(Parrot_ThisPMC_attributes);<br />   PMC_data(SELF) = attrs;<br />   ...<br />   PObj_custom_destroy_SET(SELF);<br />&#125;<br /></pre><br />The first two statements in that function allocate a new data structure to hold the PMCs internal data and stores that data into the PMC. The last line in the function indicates that the PMC needs custom destruction, likely for no other reason then to call <code>free()</code> on this same attributes structure. So for every managed PMC allocation we essentially have to call <code>malloc</code> anyway, plus we're having to run a custom destructor which adds more slowdown in the GC sweep phase!<br /><br />A more efficient method would be to bypass the GCs allocator entirely and generate new PMCs and their attributes structures in a single call like this, although it would require a few architectural changes to support it:<br /><pre><br />PMC *newpmc = (PMC *)malloc(sizeof(PMC) + sizeof(Parrot_ThisPMC_attributes));<br />PMC_data(newpmc) = ((char *)newpmc) + sizeof(PMC);<br /></pre><br />This method is obviously not good for a number of reasons: we lose out on the benefits of using the managed pool allocator, we have to use all sorts of funky pointer arithmeitc, we would need to make architectural changes to support this, etc. There are some benefits though, such as having to only call <code>free()</code> once to free the PMC and it's associated structure, and reducing the need to call custom destructors just to free these structures.<br /><br />A better idea still, although one that would require some work to implement, would be to allocate these little fixed-sized structures from the fixed-sized pools. That would require that we migrate the "bufferlike" objects to be allocated from somewhere else instead, which (since there are only two types of bufferlike objects right now) would not be so hard to do. Once that happens we can change the GC so it treats these pools like simple buffers instead of PObj aggregates. The GC would still allocate and deallocate the objects, but it wouldn't need to mark or sweep them automatically. We could then use a new PObj flag to mark PMCs that use an allocated object, and have the GC deallocate that buffer at the same time it's parent PMC is deallocated, thus negating the use of custom destroy VTABLEs that serve only that purpose.<br /><br />This is all not to mention the fact that <code>pmc_ext</code> structures, which are currently allocated not only from their own pool but also through their own custom GC routines could be added to the sized pools as well and shrunk in size by at least one pointer. Plus, we could cut out all the custom code that manages these things, and I definitely love cutting out code.<br /><br />There's some major work to be done on this project, but I predict it will have a substantial positive impact on Parrot performance and will go a long way to helping the entire GC system mature.