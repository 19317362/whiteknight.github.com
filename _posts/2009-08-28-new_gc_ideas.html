---
layout: bloggerpost
title: New GC Ideas
---

Last year for GSOC I tried to implement a custom GC algorithm for Parrot. It would be an incremental tri-color collector that used a series of linked lists to keep track of objects and their current status. For a variety of reasons I wasn't able to get that working correctly, and my attempts at creating a new GC for Parrot have been stalled ever since.<br /><br />Today chromatic had a very interesting idea to improve the algorthm which he was happy to share. The idea is to use another linked list to keep track of items that plausibly could be garbage, and only sweep through that list instead of sweeping the entire pool.<br /><br />First, let's look at how Parrot does GC now. Every PObj has a flag field which can contain bitwise flags for a number of different purposes. Two flags are of particular interest, three patterns of them are used in the GC: Free, Alive, and Dead. Before objects are allocated, the are on the free list and marked Free. We allocate and use them, then we do a GC mark, turning objects that are actively used to Alive and turning objects that are not actively used Dead. The GC sweep phase moves along the pools in a linear fashion, taking items that are Dead and making them Free, and taking items that are Alive and marking them Dead (so the next mark phase can turn the active objects Alive, and leave the inactive ones Dead for the sweeper).<br /><br />What I was trying to do in GSOC was very similar, but different in a few key regards. First, instead of using flag values, I used linked lists to keep track of objects. There was a free list, a list of completely-marked "Black" objects, and a list of partially-marked "Grey" objects. Objects without a valid linked-list pointer were in limbo, the GC mark would move through the data graph and put objects first onto the Grey list, then when they were fully marked the item was moved to the Black list. This scheme gave us some interesting heuristics. First, if the linked-list pointer was non-null, it was marked (or free). During the mark, we could pause (hence the "incremental" adjective), and continue later by walking the Grey list from the root and marking all it's contents Black. We don't need to know which list an item is on, only that it is on a list or not and that we can reach it by starting at a root and walking the list. We gain incremental behavior, but don't really see a performance increase.<br /><br />chromatic's idea builds on my algorithm but adds another feature: a Possibly Garbage list. This list would be separate and distinct from the other lists, so would require another pointer added to the stucture to support it. The heuristic here is that we don't need to sweep over all PObjs, because at any given time a large portion of available PObjs will be on the free list. We only need to sweep objects which have been allocated and abandoned.<br /><br />When we allocate an object, we set the first linked list pointer to NULL, and use the new pointer to add it to the Possibly Garbage list. The mark phase proceeds like normal, but the sweep phase has some subtle differences. First, we don't sweep the entire pool. We only sweep items on the Possibly Garbage list. This should produce some nice savings alone. As we sweep, we take dead items out of the Possibly Garbage list and move them to the Free list, leaving other items where they are (though moving them from the Black list back to the White list like normal).<br />